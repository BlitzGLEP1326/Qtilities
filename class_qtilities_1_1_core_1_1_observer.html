<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Qtilities: Qtilities::Core::Observer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_qtilities.html">Qtilities</a></li><li class="navelem"><a class="el" href="namespace_qtilities_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Qtilities::Core::Observer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The observer class is an extended implementation of an observer in the subject-observer pattern.  
 <a href="class_qtilities_1_1_core_1_1_observer.html#details">More...</a></p>

<p><code>#include &lt;Observer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Qtilities::Core::Observer:</div>
<div class="dyncontent">
<div class="center"><img src="class_qtilities_1_1_core_1_1_observer__inherit__graph.jpg" border="0" usemap="#_qtilities_1_1_core_1_1_observer_inherit__map" alt="Inheritance graph"/></div>
<map name="_qtilities_1_1_core_1_1_observer_inherit__map" id="_qtilities_1_1_core_1_1_observer_inherit__map">
<area shape="rect" id="node12" href="class_qtilities_1_1_core_gui_1_1_tree_node.html" title="The TreeNode class is a node in a tree which can have items attached to it and can also be attached t..." alt="" coords="641,74,761,121"/><area shape="rect" id="node2" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html" title="Objects can implement this interface if they are able to export and reconstruct themselves." alt="" coords="219,5,384,51"/><area shape="rect" id="node4" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base.html" title="Interface through which QObjects implementing interfaces can be accessed." alt="" coords="5,39,171,86"/><area shape="rect" id="node6" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html" title="Interface which allows objects to broadcast changes made to them." alt="" coords="219,74,384,121"/><area shape="rect" id="node9" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable_observer.html" title="Observers and observer subclasses must implement this extended version of Qtilities::Core::IExportabl..." alt="" coords="219,143,384,190"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_qtilities_1_1_core_1_1_observer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a62e08632625c83703a4e5864ff83f374"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a> { <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374ad4cbe6cefcc410de83160b8675e5c767">FullAccess</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374a46bfb7915468343fe9d3e4140bb707a5">ReadOnlyAccess</a> =  1, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374a1d318f6e15293b4c205f798533ef979d">LockedAccess</a> =  2, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374a22e659b9ebb954253f023c080ea90122">InvalidAccess</a> =  3
 }</td></tr>
<tr class="memdesc:a62e08632625c83703a4e5864ff83f374"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible access modes of the observer.  <a href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">More...</a><br/></td></tr>
<tr class="memitem:a431b95290ff04ce9b1ea81f28924bf47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a> { <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47a6e59b53e8899539a78f0a97839e8bc58">GlobalScope</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47a656444c151a84d9554640b44bebb08ac">CategorizedScope</a> =  1
 }</td></tr>
<tr class="memdesc:a431b95290ff04ce9b1ea81f28924bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access mode scope of the observer.  <a href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">More...</a><br/></td></tr>
<tr class="memitem:acf13e78d10a43dd5424a563cca4b6ca7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">EvaluationResult</a> { <br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7ac062904864836fbbef1b690c18abd75e">Allowed</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7a75fb8e893b48238d84828f6824b06de8">Conditional</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7af22010e703a1e8b2488106ca4a386c1c">Rejected</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7a02a3051a47674b9c3154ae8f65b4ff15">IsParentObserver</a>, 
<br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7a943757e4b499298101e5f5425f15a5c1">LastScopedObserver</a>
<br/>
 }</td></tr>
<tr class="memdesc:acf13e78d10a43dd5424a563cca4b6ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumeration is used to return results when validating attachment and detachment of subjects.  <a href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">More...</a><br/></td></tr>
<tr class="memitem:ac10bd670cc699870807b5b684461ba8b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a> { <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8bae7f040d2afa882212c33c17464277bee">DeleteImmediately</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8bac605f0218c0969eadfcfc1f7cf20668f">DeleteLater</a> =  1
 }</td></tr>
<tr class="memdesc:ac10bd670cc699870807b5b684461ba8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible deletion methods that <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> can use when deleting objects attached to it.  <a href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">More...</a><br/></td></tr>
<tr class="memitem:aee321cdb07667b5fe20d03a59e9ff17e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">ObjectOwnership</a> { <br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">ManualOwnership</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea27e56daee599802358d1b29381e2c5d0">AutoOwnership</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eab8616ed1c4b4bad93132614d2125c2f1">SpecificObserverOwnership</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e">ObserverScopeOwnership</a>, 
<br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97aee1aa43bfdc794423576e2c32598e">OwnedBySubjectOwnership</a>
<br/>
 }</td></tr>
<tr class="memdesc:aee321cdb07667b5fe20d03a59e9ff17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible ownerships with which subjects can be attached to an observer.  <a href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">More...</a><br/></td></tr>
<tr class="memitem:a35b36877048980c1e9acdb1a9ad586ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586ef">SubjectChangeIndication</a> { <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586efa579560dabf803bac4460af73537a38b3">SubjectAdded</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586efa59cf648266233512ce0182dd53922be3">SubjectRemoved</a>, 
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586efa21bda231f103f0e03d216c07d491eb97">CyclicProcess</a>
 }</td></tr>
<tr class="memdesc:a35b36877048980c1e9acdb1a9ad586ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible indications that can be returned when the number of subjects in the observer changes.  <a href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586ef">More...</a><br/></td></tr>
<tr class="inherit_header pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable')"><img src="closed.png" alt="-"/>&nbsp;Public Types inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html">Qtilities::Core::Interfaces::IExportable</a></td></tr>
<tr class="memitem:a0b511edb6513a9014e5d0c033c64830e inherit pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830e">ExportMode</a> { <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830eadb0296ddc7c7ad3b996faac735692274">None</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830ea94418c6ffcf362c60cf5d83a042b56e0">Binary</a> =  1, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830ea77c3e4b9db4c5dcac56e0a44650a8530">XML</a> =  2
 }</td></tr>
<tr class="memdesc:a0b511edb6513a9014e5d0c033c64830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible export modes that an implementation of <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html" title="Objects can implement this interface if they are able to export and reconstruct themselves.">IExportable</a> can support.  <a href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830e">More...</a><br/></td></tr>
<tr class="memitem:acd6f0b0cb325ed46704160377b51d045 inherit pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045">Result</a> { <br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a89de78263d24f8aa6365ff6881dedeaa">Complete</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a79f73b8a5299a81aa905d6dc4827d210">Incomplete</a> =  1, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a67eeeff82da040bba0e04c98a2780a23">Failed</a> =  2, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a9206686087ae8bd5e5129ed127c5dbb4">FailedContinue</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a0b26d6585c558fb1cc745ad6b795872d">VersionTooNew</a> =  8, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a6121d602cc7cc1ed955947ef51282dbc">VersionTooOld</a> =  16, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a89b6ab8a167764994813ff671b6b55a6">VersionSupported</a> =  32, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a443a9b84067a1928d1a6ed34e84aba3b">SuccessResult</a> =  Complete | Incomplete | VersionSupported, 
<br/>
&#160;&#160;<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045a28219b0cc99cb5d79427ce22cb8485c0">FailedResult</a> =  Failed | FailedContinue | VersionTooNew | VersionTooOld
<br/>
 }</td></tr>
<tr class="memdesc:acd6f0b0cb325ed46704160377b51d045"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of an export/import operation.  <a href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045">More...</a><br/></td></tr>
<tr class="inherit_header pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier')"><img src="closed.png" alt="-"/>&nbsp;Public Types inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html">Qtilities::Core::Interfaces::IModificationNotifier</a></td></tr>
<tr class="memitem:ad72709e0da71bdace37c372765c5c556 inherit pub_types_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556">NotificationTarget</a> { <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556a9801037988a76c86d40bc8305e2fb1b1">NotifyNone</a> =  0, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556acaf1eec374195b1a1551a858161d90e1">NotifyListeners</a> =  1, 
<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556af0ab6b3b6851a893c0e1b6ed635aa4eb">NotifySubjects</a> =  2
 }</td></tr>
<tr class="memdesc:ad72709e0da71bdace37c372765c5c556"><td class="mdescLeft">&#160;</td><td class="mdescRight">The targets which should be notified when the state of the object implementing this interface changes.  <a href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:a9f44ef3c1b4f0ca6348a3c507589787f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9f44ef3c1b4f0ca6348a3c507589787f">deleteAll</a> (const QString &amp;base_class_name=&quot;QObject&quot;, bool refresh_views=true)</td></tr>
<tr class="memdesc:a9f44ef3c1b4f0ca6348a3c507589787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to delete all currenlty observed subjects.  <a href="#a9f44ef3c1b4f0ca6348a3c507589787f"></a><br/></td></tr>
<tr class="memitem:adefcba25b55a45bbe0e4f72e4ba0fbb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#adefcba25b55a45bbe0e4f72e4ba0fbb0">detachAll</a> ()</td></tr>
<tr class="memdesc:adefcba25b55a45bbe0e4f72e4ba0fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to detach all currently observed subjects.  <a href="#adefcba25b55a45bbe0e4f72e4ba0fbb0"></a><br/></td></tr>
<tr class="memitem:a9eacee75add5520dd269b1ee880e70f2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9eacee75add5520dd269b1ee880e70f2">detachSubject</a> (QObject *obj, QString *rejectMsg=0)</td></tr>
<tr class="memdesc:a9eacee75add5520dd269b1ee880e70f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will attempt to detach the specified object from the observer.  <a href="#a9eacee75add5520dd269b1ee880e70f2"></a><br/></td></tr>
<tr class="memitem:abf06c71688ebaed01c7b621effb04991"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; QPointer<br class="typebreak"/>
&lt; QObject &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abf06c71688ebaed01c7b621effb04991">detachSubjects</a> (QList&lt; QObject * &gt; objects, QString *rejectMsg=0)</td></tr>
<tr class="memdesc:abf06c71688ebaed01c7b621effb04991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will attempt to detach the specified object objects in the list from the observer.  <a href="#abf06c71688ebaed01c7b621effb04991"></a><br/></td></tr>
<tr class="memitem:af7bbc58f173505a686c7b9acbd9989c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af7bbc58f173505a686c7b9acbd9989c4">setModificationState</a> (bool new_state, IModificationNotifier::NotificationTargets notification_targets=<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556acaf1eec374195b1a1551a858161d90e1">IModificationNotifier::NotifyListeners</a>, bool force_notifications=false)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:af35f5c204b850bbbaaf0b042a5eef585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af35f5c204b850bbbaaf0b042a5eef585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af35f5c204b850bbbaaf0b042a5eef585">aboutToBeDeleted</a> ()</td></tr>
<tr class="memdesc:af35f5c204b850bbbaaf0b042a5eef585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emitted when an observer is about to be deleted, thus its emitted in the beginning of the observer's destructor. <br/></td></tr>
<tr class="memitem:a0b66e4f2c6312910d940ef61a3a5de91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b66e4f2c6312910d940ef61a3a5de91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b66e4f2c6312910d940ef61a3a5de91">allSubjectsAboutToBeDeleted</a> ()</td></tr>
<tr class="memdesc:a0b66e4f2c6312910d940ef61a3a5de91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emitted just before all subjects are about to be deleted. <br/></td></tr>
<tr class="memitem:a3bdba8f0d9563b8a02d98bdce226b515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bdba8f0d9563b8a02d98bdce226b515"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a3bdba8f0d9563b8a02d98bdce226b515">allSubjectsAboutToBeDetached</a> ()</td></tr>
<tr class="memdesc:a3bdba8f0d9563b8a02d98bdce226b515"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emitted just before all subjects are about to be detached. <br/></td></tr>
<tr class="memitem:af547efc6c985f95ea718bea5c112f477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af547efc6c985f95ea718bea5c112f477"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af547efc6c985f95ea718bea5c112f477">allSubjectsDeleted</a> ()</td></tr>
<tr class="memdesc:af547efc6c985f95ea718bea5c112f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emitted after all subjects were deleted. <br/></td></tr>
<tr class="memitem:ac0f357c92c7c23879d329d946027f6c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f357c92c7c23879d329d946027f6c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac0f357c92c7c23879d329d946027f6c0">allSubjectsDetached</a> ()</td></tr>
<tr class="memdesc:ac0f357c92c7c23879d329d946027f6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emitted after all subjects were to be detached. <br/></td></tr>
<tr class="memitem:afa00359a136283610161bf2d82a7114e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#afa00359a136283610161bf2d82a7114e">dataChanged</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *observer=0)</td></tr>
<tr class="memdesc:afa00359a136283610161bf2d82a7114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal which is emitted when the data in the observer or the tree underneath it changes.  <a href="#afa00359a136283610161bf2d82a7114e"></a><br/></td></tr>
<tr class="memitem:a2881fecc87616d51f2e222f94b522458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458">layoutChanged</a> (QList&lt; QPointer&lt; QObject &gt; &gt; new_selection=QList&lt; QPointer&lt; QObject &gt; &gt;())</td></tr>
<tr class="memdesc:a2881fecc87616d51f2e222f94b522458"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal which is emitted when the layout of the observer or the tree underneath it changes.  <a href="#a2881fecc87616d51f2e222f94b522458"></a><br/></td></tr>
<tr class="memitem:af8729f719113e4e9183f1cf3cbbb2796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af8729f719113e4e9183f1cf3cbbb2796">modificationStateChanged</a> (bool is_modified) const </td></tr>
<tr class="memdesc:af8729f719113e4e9183f1cf3cbbb2796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function as a signal when implementing the object.  <a href="#af8729f719113e4e9183f1cf3cbbb2796"></a><br/></td></tr>
<tr class="memitem:aaeef96b6b380c12667adb82c48f7cdc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaeef96b6b380c12667adb82c48f7cdc2">monitoredPropertyChanged</a> (const char *property_name, QList&lt; QObject * &gt; objects=QList&lt; QObject * &gt;())</td></tr>
<tr class="memdesc:aaeef96b6b380c12667adb82c48f7cdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal which is emitted as soon as a monitored property of the observer or any of the installed subject filters changed.  <a href="#aaeef96b6b380c12667adb82c48f7cdc2"></a><br/></td></tr>
<tr class="memitem:ae0f3a77740427719bdbf77876bb4411c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0f3a77740427719bdbf77876bb4411c">numberOfSubjectsChanged</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586ef">Observer::SubjectChangeIndication</a> change_indication, QList&lt; QPointer&lt; QObject &gt; &gt; objects=QList&lt; QPointer&lt; QObject &gt; &gt;())</td></tr>
<tr class="memdesc:ae0f3a77740427719bdbf77876bb4411c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal which is emitted when the number of subjects change in this observer context.  <a href="#ae0f3a77740427719bdbf77876bb4411c"></a><br/></td></tr>
<tr class="memitem:ad00a5cdf6c98b5120375cf1185dc31c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00a5cdf6c98b5120375cf1185dc31c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ad00a5cdf6c98b5120375cf1185dc31c9">processingCycleEnded</a> ()</td></tr>
<tr class="memdesc:ad00a5cdf6c98b5120375cf1185dc31c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal which is emitted when this observer exists a processing cycle. <br/></td></tr>
<tr class="memitem:a9c0d5acccdf0b823df31574d5d37dab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0d5acccdf0b823df31574d5d37dab9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9c0d5acccdf0b823df31574d5d37dab9">processingCycleStarted</a> ()</td></tr>
<tr class="memdesc:a9c0d5acccdf0b823df31574d5d37dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal which is emitted when this observer enters a processing cycle. <br/></td></tr>
<tr class="memitem:abecf544807a89ac1e4150bb08098b254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abecf544807a89ac1e4150bb08098b254">propertyChangeFiltered</a> (const char *property_name, QList&lt; QObject * &gt; objects=QList&lt; QObject * &gt;())</td></tr>
<tr class="memdesc:abecf544807a89ac1e4150bb08098b254"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal which is emitted as soon as an property change event is filtered.  <a href="#abecf544807a89ac1e4150bb08098b254"></a><br/></td></tr>
<tr class="memitem:aaa5bf62140126627f7ade3e6c97710aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5bf62140126627f7ade3e6c97710aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaa5bf62140126627f7ade3e6c97710aa">subjectDeleted</a> (QObject *obj)</td></tr>
<tr class="memdesc:aaa5bf62140126627f7ade3e6c97710aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will be emitted when a subject is deleted. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fb93511941be6fbf65b6faf63f9013a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1fb93511941be6fbf65b6faf63f9013a">accessMode</a> (<a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> category=<a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>()) const </td></tr>
<tr class="memdesc:a1fb93511941be6fbf65b6faf63f9013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the observer's access mode.  <a href="#a1fb93511941be6fbf65b6faf63f9013a"></a><br/></td></tr>
<tr class="memitem:a0b9134f8702c6b25ea62d6bc75efac89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b9134f8702c6b25ea62d6bc75efac89">accessModeScope</a> () const </td></tr>
<tr class="memdesc:a0b9134f8702c6b25ea62d6bc75efac89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the access mode scope of the observer.  <a href="#a0b9134f8702c6b25ea62d6bc75efac89"></a><br/></td></tr>
<tr class="memitem:aa900e73ea3ad2292782a45c11adb2d67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa900e73ea3ad2292782a45c11adb2d67">attachSubject</a> (QObject *obj, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a> ownership=<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>, QString *rejectMsg=0, bool import_cycle=false)</td></tr>
<tr class="memdesc:aa900e73ea3ad2292782a45c11adb2d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will attempt to attach the specified object to the observer. The success of this operation depends on the installed subject filters, as well as the dynamic properties defined for the object to be attached.  <a href="#aa900e73ea3ad2292782a45c11adb2d67"></a><br/></td></tr>
<tr class="memitem:a5a65d50b41a1f54e66a709d1f3b6291f"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; QPointer<br class="typebreak"/>
&lt; QObject &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a5a65d50b41a1f54e66a709d1f3b6291f">attachSubjects</a> (QList&lt; QObject * &gt; objects, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a> ownership=<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>, QString *rejectMsg=0, bool import_cycle=false)</td></tr>
<tr class="memdesc:a5a65d50b41a1f54e66a709d1f3b6291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will attempt to attach the specified objects to the observer.  <a href="#a5a65d50b41a1f54e66a709d1f3b6291f"></a><br/></td></tr>
<tr class="memitem:a237ebcbb90a05f734b2b0e417fdbcef2"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; QPointer<br class="typebreak"/>
&lt; QObject &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a237ebcbb90a05f734b2b0e417fdbcef2">attachSubjects</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html">ObserverMimeData</a> *mime_data_object, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a> ownership=<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>, QString *rejectMsg=0, bool import_cycle=false)</td></tr>
<tr class="memdesc:a237ebcbb90a05f734b2b0e417fdbcef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will attempt to attach the specified objects in a <a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html" title="The ObserverMimeData stores information about subjects when Qtilities does drag and drops between Obs...">ObserverMimeData</a> object.  <a href="#a237ebcbb90a05f734b2b0e417fdbcef2"></a><br/></td></tr>
<tr class="memitem:a89aedbcefb1784ae36ff601e7160099a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a89aedbcefb1784ae36ff601e7160099a">broadcastModificationStateChangesEnabled</a> () const </td></tr>
<tr class="memdesc:a89aedbcefb1784ae36ff601e7160099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if broadcasting of modification state changes are enabled.  <a href="#a89aedbcefb1784ae36ff601e7160099a"></a><br/></td></tr>
<tr class="memitem:a966cb6090447164d56e7cf8d1b829ff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Observer::EvaluationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a966cb6090447164d56e7cf8d1b829ff7">canAttach</a> (QObject *obj, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a> ownership=<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>, QString *rejectMsg=0, bool silent=false) const </td></tr>
<tr class="memdesc:a966cb6090447164d56e7cf8d1b829ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which checks if the new object can be attached to the observer. This function also validates the attachment operation inside all installed subject filters. Note that this function does not attach it.  <a href="#a966cb6090447164d56e7cf8d1b829ff7"></a><br/></td></tr>
<tr class="memitem:abde9962f6bf417750ff12c7efd16b7cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Observer::EvaluationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abde9962f6bf417750ff12c7efd16b7cf">canAttach</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html">ObserverMimeData</a> *mime_data_object, QString *rejectMsg=0, bool silent=false) const </td></tr>
<tr class="memdesc:abde9962f6bf417750ff12c7efd16b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which checks if the objects in the <a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html" title="The ObserverMimeData stores information about subjects when Qtilities does drag and drops between Obs...">ObserverMimeData</a> object can be attached to the observer. This function also validates the attachment operation inside all installed subject filters. Note that this function does not attach it.  <a href="#abde9962f6bf417750ff12c7efd16b7cf"></a><br/></td></tr>
<tr class="memitem:af6ef91471ac2abb84f772c78bbb6fd31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Observer::EvaluationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af6ef91471ac2abb84f772c78bbb6fd31">canDetach</a> (QObject *obj, QString *rejectMsg=0) const </td></tr>
<tr class="memdesc:af6ef91471ac2abb84f772c78bbb6fd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function which checks if the object can be detached from the observer. This function also validates the detachment operation inside all installed subject filters. Note that this function does not detach it.  <a href="#af6ef91471ac2abb84f772c78bbb6fd31"></a><br/></td></tr>
<tr class="memitem:a0c11e0ee305e0839de72363d97374e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0c11e0ee305e0839de72363d97374e30">categoryAccessMode</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;category) const </td></tr>
<tr class="memdesc:a0c11e0ee305e0839de72363d97374e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the access mode for a specific category.  <a href="#a0c11e0ee305e0839de72363d97374e30"></a><br/></td></tr>
<tr class="memitem:ab26c935b46c6d708cb8e41cdf9c2b2da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab26c935b46c6d708cb8e41cdf9c2b2da">clearExportTask</a> ()</td></tr>
<tr class="memdesc:ab26c935b46c6d708cb8e41cdf9c2b2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the export task.  <a href="#ab26c935b46c6d708cb8e41cdf9c2b2da"></a><br/></td></tr>
<tr class="memitem:a16903f8e2ff2ef3efdc93218a8efd3f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16903f8e2ff2ef3efdc93218a8efd3f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a16903f8e2ff2ef3efdc93218a8efd3f2">contains</a> (const QObject *object) const </td></tr>
<tr class="memdesc:a16903f8e2ff2ef3efdc93218a8efd3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a given subject is currently observed by the observer. <br/></td></tr>
<tr class="memitem:a6caa39610e2107bf127e83f5a94e84ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a6caa39610e2107bf127e83f5a94e84ce">containsSubjectWithName</a> (const QString &amp;subject_name, Qt::CaseSensitivity cs=Qt::CaseSensitive) const </td></tr>
<tr class="memdesc:a6caa39610e2107bf127e83f5a94e84ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a subject with the specified name is currently observed by the observer.  <a href="#a6caa39610e2107bf127e83f5a94e84ce"></a><br/></td></tr>
<tr class="memitem:ab2aa612400862d0659ba0bd36824ff50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab2aa612400862d0659ba0bd36824ff50">copyHints</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">ObserverHints</a> *display_hints)</td></tr>
<tr class="memdesc:ab2aa612400862d0659ba0bd36824ff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let this observer copy a set of display hints.  <a href="#ab2aa612400862d0659ba0bd36824ff50"></a><br/></td></tr>
<tr class="memitem:a417048c7a59f6b87bf580743dc34b06d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">ObserverHints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a417048c7a59f6b87bf580743dc34b06d">displayHints</a> () const </td></tr>
<tr class="memdesc:a417048c7a59f6b87bf580743dc34b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a pointer to the <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">ObserverHints</a> used by this observer.  <a href="#a417048c7a59f6b87bf580743dc34b06d"></a><br/></td></tr>
<tr class="memitem:a1c355778ad9caa8a9237f192a7a6a12e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e">endProcessingCycle</a> (bool broadcast=true)</td></tr>
<tr class="memdesc:a1c355778ad9caa8a9237f192a7a6a12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a processing cycle.  <a href="#a1c355778ad9caa8a9237f192a7a6a12e"></a><br/></td></tr>
<tr class="memitem:abc3ba640a0dd9be561c6e0ea25cb5f40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abc3ba640a0dd9be561c6e0ea25cb5f40">endTreeProcessingCycle</a> (bool broadcast=true)</td></tr>
<tr class="memdesc:abc3ba640a0dd9be561c6e0ea25cb5f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a processing cycle.  <a href="#abc3ba640a0dd9be561c6e0ea25cb5f40"></a><br/></td></tr>
<tr class="memitem:a3651ff7e55eefa906c3c28b9f52735c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a3651ff7e55eefa906c3c28b9f52735c6">eventFilter</a> (QObject *object, QEvent *event)</td></tr>
<tr class="memdesc:a3651ff7e55eefa906c3c28b9f52735c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event filter filters property change events on all subjects.  <a href="#a3651ff7e55eefa906c3c28b9f52735c6"></a><br/></td></tr>
<tr class="memitem:ac014f0fe013c48b15ad9c9fe6291e56c"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
IExportable::ExportResultFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac014f0fe013c48b15ad9c9fe6291e56c">exportBinary</a> (QDataStream &amp;stream) const </td></tr>
<tr class="memdesc:ac014f0fe013c48b15ad9c9fe6291e56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows exporting to a QDataStream.  <a href="#ac014f0fe013c48b15ad9c9fe6291e56c"></a><br/></td></tr>
<tr class="memitem:a3c4b4ca4a8c6e68cc20e489b78eece98"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
IExportable::ExportResultFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a3c4b4ca4a8c6e68cc20e489b78eece98">exportXml</a> (QDomDocument *doc, QDomElement *object_node) const </td></tr>
<tr class="memdesc:a3c4b4ca4a8c6e68cc20e489b78eece98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows exporting to an XML document. A reference to the QDomElement to which the object's information must be added is provided, along with a reference to the QDomDocument.  <a href="#a3c4b4ca4a8c6e68cc20e489b78eece98"></a><br/></td></tr>
<tr class="memitem:a57ed14bed73159d5281a75b1e64fe599"><td class="memItemLeft" align="right" valign="top">QVariant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57ed14bed73159d5281a75b1e64fe599">getMultiContextPropertyValue</a> (const QObject *obj, const char *property_name) const </td></tr>
<tr class="memdesc:a57ed14bed73159d5281a75b1e64fe599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which will get the value of a <a class="el" href="class_qtilities_1_1_core_1_1_multi_context_property.html" title="A MultiContextProperty provides a property which has different values in different contexts...">MultiContextProperty</a> based dynamic property, and not the observer property itself.  <a href="#a57ed14bed73159d5281a75b1e64fe599"></a><br/></td></tr>
<tr class="memitem:ac742dc9e9e5a2746301794b941bc334a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac742dc9e9e5a2746301794b941bc334a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac742dc9e9e5a2746301794b941bc334a">hasCategory</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;category) const </td></tr>
<tr class="memdesc:ac742dc9e9e5a2746301794b941bc334a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified category exists in this observer context. <br/></td></tr>
<tr class="memitem:a2654685c15319f119a02f0344cce3eed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2654685c15319f119a02f0344cce3eed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2654685c15319f119a02f0344cce3eed">hasSubjectFilter</a> (const QString &amp;filter_name) const </td></tr>
<tr class="memdesc:a2654685c15319f119a02f0344cce3eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a subject filter with the specified name already exists in this context. <br/></td></tr>
<tr class="memitem:a7b65f6056401863d92b197e82e707752"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
IExportable::ExportResultFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7b65f6056401863d92b197e82e707752">importBinary</a> (QDataStream &amp;stream, QList&lt; QPointer&lt; QObject &gt; &gt; &amp;import_list)</td></tr>
<tr class="memitem:aa133ba40b8048e87bc6a80d4a0af45e2"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
IExportable::ExportResultFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa133ba40b8048e87bc6a80d4a0af45e2">importXml</a> (QDomDocument *doc, QDomElement *object_node, QList&lt; QPointer&lt; QObject &gt; &gt; &amp;import_list)</td></tr>
<tr class="memitem:ad6c48e66ac4dadb59760923d7915abc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ad6c48e66ac4dadb59760923d7915abc6">installSubjectFilter</a> (<a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html">AbstractSubjectFilter</a> *subject_filter)</td></tr>
<tr class="memdesc:ad6c48e66ac4dadb59760923d7915abc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a new subject filter.  <a href="#ad6c48e66ac4dadb59760923d7915abc6"></a><br/></td></tr>
<tr class="memitem:a54fbff815e7f257ae8172656592df8df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_instance_factory_info.html">InstanceFactoryInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a54fbff815e7f257ae8172656592df8df">instanceFactoryInfo</a> () const </td></tr>
<tr class="memdesc:a54fbff815e7f257ae8172656592df8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instance factory information which must be used when the exported object is reconstructed during an import.  <a href="#a54fbff815e7f257ae8172656592df8df"></a><br/></td></tr>
<tr class="memitem:ac46da1fd6151e3ee699729387ef6e52a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46da1fd6151e3ee699729387ef6e52a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac46da1fd6151e3ee699729387ef6e52a">isConst</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;access_mode=<a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>()) const </td></tr>
<tr class="memdesc:ac46da1fd6151e3ee699729387ef6e52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will validate changes to the observer, or to a specific observer category if specified. <br/></td></tr>
<tr class="memitem:a1fd993126d842d6f226bbc6e3faab2d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd993126d842d6f226bbc6e3faab2d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1fd993126d842d6f226bbc6e3faab2d8">isModified</a> () const </td></tr>
<tr class="memdesc:a1fd993126d842d6f226bbc6e3faab2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the modification state of the object. <br/></td></tr>
<tr class="memitem:a883e9ac9aba9b523fab8d6c72b762bc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6">isProcessingCycleActive</a> () const </td></tr>
<tr class="memdesc:a883e9ac9aba9b523fab8d6c72b762bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a processing cycle is active.  <a href="#a883e9ac9aba9b523fab8d6c72b762bc6"></a><br/></td></tr>
<tr class="memitem:aab01469a6574cad08f38247f25c174fd"><td class="memItemLeft" align="right" valign="top">QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aab01469a6574cad08f38247f25c174fd">monitoredProperties</a> () const </td></tr>
<tr class="memdesc:aab01469a6574cad08f38247f25c174fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a QStringList with the names of all the properties which are monitored by this observer.  <a href="#aab01469a6574cad08f38247f25c174fd"></a><br/></td></tr>
<tr class="memitem:a2aa5b3be769ae0b5a6b0acef59070fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2aa5b3be769ae0b5a6b0acef59070fe3">monitorSubjectModificationState</a> (QObject *obj)</td></tr>
<tr class="memdesc:a2aa5b3be769ae0b5a6b0acef59070fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if a subject's modification state must be monitored.  <a href="#a2aa5b3be769ae0b5a6b0acef59070fe3"></a><br/></td></tr>
<tr class="memitem:aab814e03e5fa4580b9b991fb1dc8cba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab814e03e5fa4580b9b991fb1dc8cba1"></a>
QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aab814e03e5fa4580b9b991fb1dc8cba1">objectBase</a> ()</td></tr>
<tr class="memdesc:aab814e03e5fa4580b9b991fb1dc8cba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QObject* base of the interface. <br/></td></tr>
<tr class="memitem:a59a82b6fa8fb4a53da32b7ba47a55f69"><td class="memItemLeft" align="right" valign="top">const QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a59a82b6fa8fb4a53da32b7ba47a55f69">objectBase</a> () const </td></tr>
<tr class="memdesc:a59a82b6fa8fb4a53da32b7ba47a55f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const QObject* base of the interface.  <a href="#a59a82b6fa8fb4a53da32b7ba47a55f69"></a><br/></td></tr>
<tr class="memitem:a57341193e333022bc56b08823f6b10b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1">objectDeletionPolicy</a> () const </td></tr>
<tr class="memdesc:a57341193e333022bc56b08823f6b10b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the observer's object deletion policy.  <a href="#a57341193e333022bc56b08823f6b10b1"></a><br/></td></tr>
<tr class="memitem:ae6955727eee22e2ecaf236c7aa8a321f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6955727eee22e2ecaf236c7aa8a321f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f">Observer</a> (const QString &amp;observer_name=QString(), const QString &amp;observer_description=QString(), QObject *parent=0)</td></tr>
<tr class="memdesc:ae6955727eee22e2ecaf236c7aa8a321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="memitem:a91555d9a7b5d9d595a15d4f36e3a512d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91555d9a7b5d9d595a15d4f36e3a512d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a91555d9a7b5d9d595a15d4f36e3a512d">Observer</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> &amp;other)</td></tr>
<tr class="memdesc:a91555d9a7b5d9d595a15d4f36e3a512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:a69fd583cec462d3ce2b6666505e99292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fd583cec462d3ce2b6666505e99292"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a69fd583cec462d3ce2b6666505e99292">observerDescription</a> () const </td></tr>
<tr class="memdesc:a69fd583cec462d3ce2b6666505e99292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observer's description. For example, a variable workspace, or a logger engine manager etc. <br/></td></tr>
<tr class="memitem:aceb6d2edf30c840d0b9dc543b2180737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb6d2edf30c840d0b9dc543b2180737"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aceb6d2edf30c840d0b9dc543b2180737">observerID</a> () const </td></tr>
<tr class="memdesc:aceb6d2edf30c840d0b9dc543b2180737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uqniue ID assigned to this observer by the <a class="el" href="class_qtilities_1_1_core_1_1_object_manager.html" title="The ObjectManager provides object management features to the developer.">ObjectManager</a>. <br/></td></tr>
<tr class="memitem:a39d450a3f5be2b4e05ded3411a251890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39d450a3f5be2b4e05ded3411a251890"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a39d450a3f5be2b4e05ded3411a251890">observerName</a> (int parent_id=-1) const </td></tr>
<tr class="memdesc:a39d450a3f5be2b4e05ded3411a251890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observer's name within a context. If a context is not specified, the objectName() of the observer is returned. <br/></td></tr>
<tr class="memitem:a18306191e5408decd91a7fe17ce1e385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18306191e5408decd91a7fe17ce1e385"></a>
<a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a18306191e5408decd91a7fe17ce1e385">operator&lt;&lt;</a> (QObject *subject)</td></tr>
<tr class="memdesc:a18306191e5408decd91a7fe17ce1e385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload &lt;&lt; operator so that we can attach subjects using the operator. <br/></td></tr>
<tr class="memitem:ab498ec14b0ac0dc881867c9e6ac93bdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab498ec14b0ac0dc881867c9e6ac93bdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab498ec14b0ac0dc881867c9e6ac93bdd">processingCycleCount</a> () const </td></tr>
<tr class="memdesc:ab498ec14b0ac0dc881867c9e6ac93bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the number of times processing cycles has been started. <br/></td></tr>
<tr class="memitem:aa987965179b19d1f655de3690b05acc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa987965179b19d1f655de3690b05acc1">qtilitiesPropertyChangeEventsEnabled</a> () const </td></tr>
<tr class="memdesc:aa987965179b19d1f655de3690b05acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if QtilitiesPropertyChangeEvents are enabled.  <a href="#aa987965179b19d1f655de3690b05acc1"></a><br/></td></tr>
<tr class="memitem:ae0cfe4e31430b26561a3343eac0174c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0cfe4e31430b26561a3343eac0174c4">refreshViewsData</a> (bool force=false)</td></tr>
<tr class="memdesc:ae0cfe4e31430b26561a3343eac0174c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to refresh the data views showing this observer.  <a href="#ae0cfe4e31430b26561a3343eac0174c4"></a><br/></td></tr>
<tr class="memitem:a240709fed2b99aba07424d19ec80de0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a240709fed2b99aba07424d19ec80de0c">refreshViewsLayout</a> (QList&lt; QPointer&lt; QObject &gt; &gt; new_selection=QList&lt; QPointer&lt; QObject &gt; &gt;(), bool force=false)</td></tr>
<tr class="memdesc:a240709fed2b99aba07424d19ec80de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to refresh the layout views showing this observer.  <a href="#a240709fed2b99aba07424d19ec80de0c"></a><br/></td></tr>
<tr class="memitem:a9b689899ede9f68e4c1938a4e198f0ab"><td class="memItemLeft" align="right" valign="top">QList&lt; QPointer&lt; QObject &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9b689899ede9f68e4c1938a4e198f0ab">renameCategory</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;old_category, const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;new_category, bool match_exactly=true)</td></tr>
<tr class="memdesc:a9b689899ede9f68e4c1938a4e198f0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames <code>old_category</code> to <code>new_category</code> in this observer context.  <a href="#a9b689899ede9f68e4c1938a4e198f0ab"></a><br/></td></tr>
<tr class="memitem:a9f5624a60522c9885aca302b5aa1a166"><td class="memItemLeft" align="right" valign="top">QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9f5624a60522c9885aca302b5aa1a166">reservedProperties</a> () const </td></tr>
<tr class="memdesc:a9f5624a60522c9885aca302b5aa1a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a QStringList with the names of all the reserved properties inside this observer context.  <a href="#a9f5624a60522c9885aca302b5aa1a166"></a><br/></td></tr>
<tr class="memitem:a55b5ef9e6c8d0f984c470fd4a51af3f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55b5ef9e6c8d0f984c470fd4a51af3f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a55b5ef9e6c8d0f984c470fd4a51af3f1">resetProcessingCycleCount</a> (bool broadcast=true)</td></tr>
<tr class="memdesc:a55b5ef9e6c8d0f984c470fd4a51af3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which resets the processing cycle count on the observer. <br/></td></tr>
<tr class="memitem:a0f358e1fd5410c64067c687691947ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0f358e1fd5410c64067c687691947ea3">setAccessMode</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a> mode, <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> category=<a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>())</td></tr>
<tr class="memdesc:a0f358e1fd5410c64067c687691947ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the observer's access mode. Set the access mode after construction. When subclassing <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, set it in your constructor.  <a href="#a0f358e1fd5410c64067c687691947ea3"></a><br/></td></tr>
<tr class="memitem:a546182e85f9c9800adb6eae244aa9412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a546182e85f9c9800adb6eae244aa9412"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a546182e85f9c9800adb6eae244aa9412">setAccessModeScope</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a> access_mode_scope)</td></tr>
<tr class="memdesc:a546182e85f9c9800adb6eae244aa9412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the observer's access mode scope. <br/></td></tr>
<tr class="memitem:a8013687ec1e85183a4df1ba5423f7bba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a8013687ec1e85183a4df1ba5423f7bba">setApplicationExportVersion</a> (quint32 version)</td></tr>
<tr class="memdesc:a8013687ec1e85183a4df1ba5423f7bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application export version currently used by all your application's classes.  <a href="#a8013687ec1e85183a4df1ba5423f7bba"></a><br/></td></tr>
<tr class="memitem:a8f2431a878d6baeb23be5560eb2cdc77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a8f2431a878d6baeb23be5560eb2cdc77">setExportTask</a> (<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_task.html">ITask</a> *task)</td></tr>
<tr class="memdesc:a8f2431a878d6baeb23be5560eb2cdc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task which must be used to log import/export information to.  <a href="#a8f2431a878d6baeb23be5560eb2cdc77"></a><br/></td></tr>
<tr class="memitem:a5a29cc3472e868277313987bb65070fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a5a29cc3472e868277313987bb65070fc">setExportVersion</a> (<a class="el" href="namespace_qtilities.html#a46a5ca954966c57c74662ac6e6d8aa25">Qtilities::ExportVersion</a> version)</td></tr>
<tr class="memdesc:a5a29cc3472e868277313987bb65070fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the export version currently used by all Qtilities classes.  <a href="#a5a29cc3472e868277313987bb65070fc"></a><br/></td></tr>
<tr class="memitem:a9a35efa0f88de6961e24c276c6d13e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9a35efa0f88de6961e24c276c6d13e40">setMonitorSubjectModificationState</a> (QObject *obj, bool monitor)</td></tr>
<tr class="memdesc:a9a35efa0f88de6961e24c276c6d13e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if a subject's modification state must be monitored.  <a href="#a9a35efa0f88de6961e24c276c6d13e40"></a><br/></td></tr>
<tr class="memitem:a6087d7dcaeee42400eba23dff07f7f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a6087d7dcaeee42400eba23dff07f7f83">setMultiContextPropertyValue</a> (QObject *obj, const char *property_name, const QVariant &amp;new_value) const </td></tr>
<tr class="memdesc:a6087d7dcaeee42400eba23dff07f7f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which will set the value of a <a class="el" href="class_qtilities_1_1_core_1_1_multi_context_property.html" title="A MultiContextProperty provides a property which has different values in different contexts...">MultiContextProperty</a> based dynamic property, and not the observer property itself.  <a href="#a6087d7dcaeee42400eba23dff07f7f83"></a><br/></td></tr>
<tr class="memitem:a67e214fac1968630563da51e0c661148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a67e214fac1968630563da51e0c661148">setObjectDeletionPolicy</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a> object_deletion_policy)</td></tr>
<tr class="memdesc:a67e214fac1968630563da51e0c661148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the observer's object deletion policy.  <a href="#a67e214fac1968630563da51e0c661148"></a><br/></td></tr>
<tr class="memitem:aa4c9d6a67bdfadb8e3c6cf38f6ca136a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4c9d6a67bdfadb8e3c6cf38f6ca136a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa4c9d6a67bdfadb8e3c6cf38f6ca136a">setObserverDescription</a> (const QString &amp;description)</td></tr>
<tr class="memdesc:aa4c9d6a67bdfadb8e3c6cf38f6ca136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observer's description. For example, a variable workspace, or a logger engine manager etc. <br/></td></tr>
<tr class="memitem:ab62500e85371cbdf18b9ea2e1f88299c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab62500e85371cbdf18b9ea2e1f88299c">setSubjectLimit</a> (int subject_limit)</td></tr>
<tr class="memdesc:ab62500e85371cbdf18b9ea2e1f88299c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the subject limit of this observer.  <a href="#ab62500e85371cbdf18b9ea2e1f88299c"></a><br/></td></tr>
<tr class="memitem:a831844b0810e443776f8a2cf0b5e4d01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01">startProcessingCycle</a> ()</td></tr>
<tr class="memdesc:a831844b0810e443776f8a2cf0b5e4d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a processing cycle.  <a href="#a831844b0810e443776f8a2cf0b5e4d01"></a><br/></td></tr>
<tr class="memitem:acee4989f8b736a0d5971178d49f2bc43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acee4989f8b736a0d5971178d49f2bc43">startTreeProcessingCycle</a> ()</td></tr>
<tr class="memdesc:acee4989f8b736a0d5971178d49f2bc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a processing cycle.  <a href="#acee4989f8b736a0d5971178d49f2bc43"></a><br/></td></tr>
<tr class="memitem:a31484604f7def829d78121ac9f8d323e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31484604f7def829d78121ac9f8d323e"></a>
QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a31484604f7def829d78121ac9f8d323e">subjectAt</a> (int i) const </td></tr>
<tr class="memdesc:a31484604f7def829d78121ac9f8d323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the subject reference at a given position. <br/></td></tr>
<tr class="memitem:a7939ae4cb248ee5affddd62765e75b07"><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7939ae4cb248ee5affddd62765e75b07">subjectCategories</a> () const </td></tr>
<tr class="memdesc:a7939ae4cb248ee5affddd62765e75b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a QStringList with all the categories found in the qti_prop_CATEGORY_MAP properties of all attached subjects.  <a href="#a7939ae4cb248ee5affddd62765e75b07"></a><br/></td></tr>
<tr class="memitem:a9e3f207265d4ae4b6f627436cf8cd0f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e3f207265d4ae4b6f627436cf8cd0f8"></a>
<a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9e3f207265d4ae4b6f627436cf8cd0f8">subjectCategoryInContext</a> (const QObject *obj) const </td></tr>
<tr class="memdesc:a9e3f207265d4ae4b6f627436cf8cd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the category used for the specified object in this context. QtilitiesCategory() is returned if the object is not valid, not attached to this observer or does not have a category. <br/></td></tr>
<tr class="memitem:aabf6283727ab569ea25ba59f110270d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aabf6283727ab569ea25ba59f110270d2">subjectCount</a> (const QString &amp;base_class_name=QString()) const </td></tr>
<tr class="memdesc:aabf6283727ab569ea25ba59f110270d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of subjects currently observed by the observer.  <a href="#aabf6283727ab569ea25ba59f110270d2"></a><br/></td></tr>
<tr class="memitem:a4e476df6f4948f33aa0ee0149a975c05"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a4e476df6f4948f33aa0ee0149a975c05">subjectDisplayedNameInContext</a> (const QObject *obj, bool check_displayed_name_property=true, bool validate_object=false) const </td></tr>
<tr class="memdesc:a4e476df6f4948f33aa0ee0149a975c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the displayed name used for the specified object in this context. QString() is returned if the object is not valid or not attached to this observer.  <a href="#a4e476df6f4948f33aa0ee0149a975c05"></a><br/></td></tr>
<tr class="memitem:a6ff0e5cfa16a69da4f52ef1bc1621a82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff0e5cfa16a69da4f52ef1bc1621a82"></a>
QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a6ff0e5cfa16a69da4f52ef1bc1621a82">subjectDisplayedNames</a> (const QString &amp;base_class_name=&quot;QObject&quot;) const </td></tr>
<tr class="memdesc:a6ff0e5cfa16a69da4f52ef1bc1621a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the displayed names of all the current observed subjects which inherits a specific base class. By default all subjects' displayed names are returned. <br/></td></tr>
<tr class="memitem:a7daa3cf44ede8ce0ce6a20ac2ff5be1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a">subjectEventFilteringEnabled</a> () const </td></tr>
<tr class="memdesc:a7daa3cf44ede8ce0ce6a20ac2ff5be1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if subject event filtering is enabled.  <a href="#a7daa3cf44ede8ce0ce6a20ac2ff5be1a"></a><br/></td></tr>
<tr class="memitem:ac121c77390c6ed013f28b985494b27dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac121c77390c6ed013f28b985494b27dd"></a>
QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html">AbstractSubjectFilter</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac121c77390c6ed013f28b985494b27dd">subjectFilters</a> () const </td></tr>
<tr class="memdesc:ac121c77390c6ed013f28b985494b27dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a list of all installed subject filters. <br/></td></tr>
<tr class="memitem:a0f25a8deb910d70ad7b29dd612929f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f25a8deb910d70ad7b29dd612929f59"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0f25a8deb910d70ad7b29dd612929f59">subjectID</a> (int i) const </td></tr>
<tr class="memdesc:a0f25a8deb910d70ad7b29dd612929f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of the object at the specified position of the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>'s pointer list, returns -1 if the object was not found. <br/></td></tr>
<tr class="memitem:a78893642f36421cb651bedf78008d642"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a78893642f36421cb651bedf78008d642">subjectID</a> (const QString &amp;subject_name, Qt::CaseSensitivity cs=Qt::CaseSensitive) const </td></tr>
<tr class="memdesc:a78893642f36421cb651bedf78008d642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID associated with a specific subject.  <a href="#a78893642f36421cb651bedf78008d642"></a><br/></td></tr>
<tr class="memitem:a6cfee71a04c76f752b85c3920516ae72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cfee71a04c76f752b85c3920516ae72"></a>
QList&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a6cfee71a04c76f752b85c3920516ae72">subjectIDs</a> () const </td></tr>
<tr class="memdesc:a6cfee71a04c76f752b85c3920516ae72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IDs for all the attached subjects. <br/></td></tr>
<tr class="memitem:a71f8495b3d5a6c5aa7aada671000c26d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71f8495b3d5a6c5aa7aada671000c26d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a71f8495b3d5a6c5aa7aada671000c26d">subjectLimit</a> () const </td></tr>
<tr class="memdesc:a71f8495b3d5a6c5aa7aada671000c26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observer's subject limit. <br/></td></tr>
<tr class="memitem:a94f847b53fcec650a724f22c0bd6e550"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f847b53fcec650a724f22c0bd6e550"></a>
QMap&lt; QPointer&lt; QObject &gt;<br class="typebreak"/>
, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a94f847b53fcec650a724f22c0bd6e550">subjectMap</a> ()</td></tr>
<tr class="memdesc:a94f847b53fcec650a724f22c0bd6e550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a QMap with references to all subjects as keys with the names used for the subjects in this context as values. <br/></td></tr>
<tr class="memitem:a46c0f82fb6c599bf18c3bcf6f04ec208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c0f82fb6c599bf18c3bcf6f04ec208"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a46c0f82fb6c599bf18c3bcf6f04ec208">subjectNameInContext</a> (const QObject *obj) const </td></tr>
<tr class="memdesc:a46c0f82fb6c599bf18c3bcf6f04ec208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name used for the specified object in this context. QString() is returned if the object is not valid or not attached to this observer. <br/></td></tr>
<tr class="memitem:a7ef3963fcaab9c713363facd7f551402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ef3963fcaab9c713363facd7f551402"></a>
QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7ef3963fcaab9c713363facd7f551402">subjectNames</a> (const QString &amp;base_class_name=&quot;QObject&quot;) const </td></tr>
<tr class="memdesc:a7ef3963fcaab9c713363facd7f551402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the names of all the current observed subjects which inherits a specific base class. By default all subjects' names are returned. <br/></td></tr>
<tr class="memitem:a35481ebcae359c132a9e8ac85bb8be7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35481ebcae359c132a9e8ac85bb8be7c"></a>
QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35481ebcae359c132a9e8ac85bb8be7c">subjectNamesByCategory</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;category) const </td></tr>
<tr class="memdesc:a35481ebcae359c132a9e8ac85bb8be7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the names of all the current observed subjects which belongs to a specific category. <br/></td></tr>
<tr class="memitem:ae78402171e9b9862d64ea94785edf1cc"><td class="memItemLeft" align="right" valign="top">QList&lt; QPointer&lt; <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae78402171e9b9862d64ea94785edf1cc">subjectObserverReferences</a> () const </td></tr>
<tr class="memdesc:ae78402171e9b9862d64ea94785edf1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of observers under this observer.  <a href="#ae78402171e9b9862d64ea94785edf1cc"></a><br/></td></tr>
<tr class="memitem:a3b375085b25e4e41ba859030f28342d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">ObjectOwnership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a3b375085b25e4e41ba859030f28342d5">subjectOwnershipInContext</a> (const QObject *obj) const </td></tr>
<tr class="memdesc:a3b375085b25e4e41ba859030f28342d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ownership used for the specified object in this context.  <a href="#a3b375085b25e4e41ba859030f28342d5"></a><br/></td></tr>
<tr class="memitem:a71a23997091023c3d463807baf1b9ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a23997091023c3d463807baf1b9ce5"></a>
QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a71a23997091023c3d463807baf1b9ce5">subjectReference</a> (int ID) const </td></tr>
<tr class="memdesc:a71a23997091023c3d463807baf1b9ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the subject reference for a specific, unique subject ID. <br/></td></tr>
<tr class="memitem:a4bd2f7ddbc9ad3d82c67c00bb53fc318"><td class="memItemLeft" align="right" valign="top">QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a4bd2f7ddbc9ad3d82c67c00bb53fc318">subjectReference</a> (const QString &amp;subject_name, Qt::CaseSensitivity cs=Qt::CaseSensitive) const </td></tr>
<tr class="memdesc:a4bd2f7ddbc9ad3d82c67c00bb53fc318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the subject reference for a specific object name.  <a href="#a4bd2f7ddbc9ad3d82c67c00bb53fc318"></a><br/></td></tr>
<tr class="memitem:aca07c38b081fa8fc561e0579369e5787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca07c38b081fa8fc561e0579369e5787"></a>
QMap&lt; QPointer&lt; QObject &gt;<br class="typebreak"/>
, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aca07c38b081fa8fc561e0579369e5787">subjectReferenceCategoryMap</a> () const </td></tr>
<tr class="memdesc:aca07c38b081fa8fc561e0579369e5787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a QMap with each object in this observer mapped to its category's string representation (using toString("::") function on <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html" title="A QtilitiesCategory object represents a category in Qtilities.">QtilitiesCategory</a>). <br/></td></tr>
<tr class="memitem:af56466a58c659e96801b1dffe31b8b24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af56466a58c659e96801b1dffe31b8b24"></a>
QList&lt; QObject * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af56466a58c659e96801b1dffe31b8b24">subjectReferences</a> (const QString &amp;base_class_name=QString()) const </td></tr>
<tr class="memdesc:af56466a58c659e96801b1dffe31b8b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the subject references of all the observed subjects which inherits a specific base class. If you don't specify an interface, all QObjects in the observer are returned. <br/></td></tr>
<tr class="memitem:a2abcf09583faae0d323eb11d848f0928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2abcf09583faae0d323eb11d848f0928"></a>
QList&lt; QObject * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2abcf09583faae0d323eb11d848f0928">subjectReferencesByCategory</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;category) const </td></tr>
<tr class="memdesc:a2abcf09583faae0d323eb11d848f0928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the subject references of all the observed subjects which has the specified category set as an qti_prop_CATEGORY_MAP shared observer property. <br/></td></tr>
<tr class="memitem:a752b9be37aff4df68ef3afb808d96d42"><td class="memItemLeft" align="right" valign="top">ExportModeFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a752b9be37aff4df68ef3afb808d96d42">supportedFormats</a> () const </td></tr>
<tr class="memdesc:a752b9be37aff4df68ef3afb808d96d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information about the export format(s) supported by your implementation of IExportable.  <a href="#a752b9be37aff4df68ef3afb808d96d42"></a><br/></td></tr>
<tr class="memitem:aa2668fd3c211a83ed33134fb865cda5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa2668fd3c211a83ed33134fb865cda5c">toggleBroadcastModificationStateChanges</a> (bool toggle)</td></tr>
<tr class="memdesc:aa2668fd3c211a83ed33134fb865cda5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables broadcasting of modification state changes <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>.  <a href="#aa2668fd3c211a83ed33134fb865cda5c"></a><br/></td></tr>
<tr class="memitem:a87d841260596abf11e47d4e66a35ecc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a87d841260596abf11e47d4e66a35ecc0">toggleQtilitiesPropertyChangeEvents</a> (bool toggle)</td></tr>
<tr class="memdesc:a87d841260596abf11e47d4e66a35ecc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables delivery of QtilitiesPropertyChangeEvents on objects when property changes occurs.  <a href="#a87d841260596abf11e47d4e66a35ecc0"></a><br/></td></tr>
<tr class="memitem:acb1ccbf1beede3d16541ddf100981b41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41">toggleSubjectEventFiltering</a> (bool toggle)</td></tr>
<tr class="memdesc:acb1ccbf1beede3d16541ddf100981b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function toggles event filtering on objects.  <a href="#acb1ccbf1beede3d16541ddf100981b41"></a><br/></td></tr>
<tr class="memitem:a5163a7a6ec3ce95190fe23fb75c183c6"><td class="memItemLeft" align="right" valign="top">QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a5163a7a6ec3ce95190fe23fb75c183c6">treeAt</a> (int i) const </td></tr>
<tr class="memdesc:a5163a7a6ec3ce95190fe23fb75c183c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get a QObject reference at a specific location in the tree underneath this observer.  <a href="#a5163a7a6ec3ce95190fe23fb75c183c6"></a><br/></td></tr>
<tr class="memitem:ae7e206eda0fec302f2c5a8560ddefdc1"><td class="memItemLeft" align="right" valign="top">QList&lt; QObject * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae7e206eda0fec302f2c5a8560ddefdc1">treeChildren</a> (const QString &amp;base_class_name=&quot;QObject&quot;, int limit=-1, int iterator_id=-1) const </td></tr>
<tr class="memdesc:ae7e206eda0fec302f2c5a8560ddefdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the QObject references of all items in the tree underneath this observer.  <a href="#ae7e206eda0fec302f2c5a8560ddefdc1"></a><br/></td></tr>
<tr class="memitem:ac262131225e6395973d05e2d899a7bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac262131225e6395973d05e2d899a7bfb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac262131225e6395973d05e2d899a7bfb">treeContains</a> (QObject *tree_item) const </td></tr>
<tr class="memdesc:ac262131225e6395973d05e2d899a7bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a specific AbstractTreeItem is contained in the tree underneath this node. <br/></td></tr>
<tr class="memitem:aba45614f222c4b6d990ad1a156946efa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aba45614f222c4b6d990ad1a156946efa">treeCount</a> (const QString &amp;base_class_name=QString())</td></tr>
<tr class="memdesc:aba45614f222c4b6d990ad1a156946efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the number of children under the specified observer.  <a href="#aba45614f222c4b6d990ad1a156946efa"></a><br/></td></tr>
<tr class="memitem:a7951f5470f8fd0f48dca72bf3e162bd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7951f5470f8fd0f48dca72bf3e162bd4">uninstallSubjectFilter</a> (<a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html">AbstractSubjectFilter</a> *subject_filter)</td></tr>
<tr class="memdesc:a7951f5470f8fd0f48dca72bf3e162bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstalls a subject filter.  <a href="#a7951f5470f8fd0f48dca72bf3e162bd4"></a><br/></td></tr>
<tr class="memitem:ae61374a82580a82b344f599dec661fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">ObserverHints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0">useDisplayHints</a> ()</td></tr>
<tr class="memdesc:ae61374a82580a82b344f599dec661fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which constructs hints for this observer.  <a href="#ae61374a82580a82b344f599dec661fe0"></a><br/></td></tr>
<tr class="memitem:a24fdba0f7f8bc88ae991d3d4346b5d2a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a24fdba0f7f8bc88ae991d3d4346b5d2a">~Observer</a> ()</td></tr>
<tr class="memdesc:a24fdba0f7f8bc88ae991d3d4346b5d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> destructor.  <a href="#a24fdba0f7f8bc88ae991d3d4346b5d2a"></a><br/></td></tr>
<tr class="inherit_header pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html">Qtilities::Core::Interfaces::IExportable</a></td></tr>
<tr class="memitem:a2c374dc64d5d8d47c5ed259f1d1cac41 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a2c374dc64d5d8d47c5ed259f1d1cac41">applicationExportVersion</a> () const </td></tr>
<tr class="memdesc:a2c374dc64d5d8d47c5ed259f1d1cac41 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the application export version currently used by all your application's classes.  <a href="#a2c374dc64d5d8d47c5ed259f1d1cac41"></a><br/></td></tr>
<tr class="memitem:a53663f6696474715cb81d8e0af09157a inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html">IExportable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a53663f6696474715cb81d8e0af09157a">duplicate</a> (QString *error_msg=0, int properties_to_copy=0, ExportResultFlags *result_flags=0) const </td></tr>
<tr class="memdesc:a53663f6696474715cb81d8e0af09157a inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which will create a duplicate (copy) of this object.  <a href="#a53663f6696474715cb81d8e0af09157a"></a><br/></td></tr>
<tr class="memitem:af16b7fe85350bdf566709b3cf8e9fcb7 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_task.html">ITask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#af16b7fe85350bdf566709b3cf8e9fcb7">exportTask</a> () const </td></tr>
<tr class="memdesc:af16b7fe85350bdf566709b3cf8e9fcb7 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task which must be used to log import/export information to.  <a href="#af16b7fe85350bdf566709b3cf8e9fcb7"></a><br/></td></tr>
<tr class="memitem:a5d2012183839898b0a9dd97a3d2d55c7 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_qtilities.html#a46a5ca954966c57c74662ac6e6d8aa25">Qtilities::ExportVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a5d2012183839898b0a9dd97a3d2d55c7">exportVersion</a> () const </td></tr>
<tr class="memdesc:a5d2012183839898b0a9dd97a3d2d55c7 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the export version currently used by all Qtilities classes.  <a href="#a5d2012183839898b0a9dd97a3d2d55c7"></a><br/></td></tr>
<tr class="memitem:afd42c5618690051a78b90c44a8e4e3df inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#afd42c5618690051a78b90c44a8e4e3df">isExportable</a> () const </td></tr>
<tr class="memdesc:afd42c5618690051a78b90c44a8e4e3df inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if this object must be part of it's parents' exports.  <a href="#afd42c5618690051a78b90c44a8e4e3df"></a><br/></td></tr>
<tr class="memitem:afbf3b51cf6ed763540a61afcb1fdf9d0 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf3b51cf6ed763540a61afcb1fdf9d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#afbf3b51cf6ed763540a61afcb1fdf9d0">setIsExportable</a> (bool new_is_exportable)</td></tr>
<tr class="memdesc:afbf3b51cf6ed763540a61afcb1fdf9d0 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if this object must be part of it's parents' exports. <br/></td></tr>
<tr class="inherit_header pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base.html">Qtilities::Core::Interfaces::IObjectBase</a></td></tr>
<tr class="memitem:a3bad31f5520588df872d722bb2571dd3 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base.html#a3bad31f5520588df872d722bb2571dd3">objectOriginID</a> () const </td></tr>
<tr class="memdesc:a3bad31f5520588df872d722bb2571dd3 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows interfaces to provide some sort of source identification.  <a href="#a3bad31f5520588df872d722bb2571dd3"></a><br/></td></tr>
<tr class="memitem:a104cbed0f4b5a87e0bc592d0a43a7e63 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base.html#a104cbed0f4b5a87e0bc592d0a43a7e63">setObjectOriginID</a> (const QString &amp;object_origin_id)</td></tr>
<tr class="memdesc:a104cbed0f4b5a87e0bc592d0a43a7e63 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting of the object source ID of this interface implementation.  <a href="#a104cbed0f4b5a87e0bc592d0a43a7e63"></a><br/></td></tr>
<tr class="inherit_header pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html">Qtilities::Core::Interfaces::IModificationNotifier</a></td></tr>
<tr class="memitem:a0b6ad8dd0fd30d3f624ce36d095d2222 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#a0b6ad8dd0fd30d3f624ce36d095d2222">setModificationState</a> (bool new_state, NotificationTargets notification_targets=<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556acaf1eec374195b1a1551a858161d90e1">NotifyListeners</a>, bool force_notifications=false)=0</td></tr>
<tr class="memdesc:a0b6ad8dd0fd30d3f624ce36d095d2222 inherit pub_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the modification state of the object. Returns true if it was successfull.  <a href="#a0b6ad8dd0fd30d3f624ce36d095d2222"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1c9395397da346972c06b553e151d147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9395397da346972c06b553e151d147"></a>
static QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c9395397da346972c06b553e151d147">accessModeScopeToString</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a> access_mode_scope)</td></tr>
<tr class="memdesc:a1c9395397da346972c06b553e151d147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a string associated with a specific AccessModeScope. <br/></td></tr>
<tr class="memitem:afe76bdf2b858c9f5991ec2297e88aa76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe76bdf2b858c9f5991ec2297e88aa76"></a>
static QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#afe76bdf2b858c9f5991ec2297e88aa76">accessModeToString</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a> access_mode)</td></tr>
<tr class="memdesc:afe76bdf2b858c9f5991ec2297e88aa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a string associated with a specific AccessMode. <br/></td></tr>
<tr class="memitem:ac1a13e4720b62b9f0544dbd81722ece5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a13e4720b62b9f0544dbd81722ece5"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac1a13e4720b62b9f0544dbd81722ece5">isParentInHierarchy</a> (const <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *obj_to_check, const <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *observer)</td></tr>
<tr class="memdesc:ac1a13e4720b62b9f0544dbd81722ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will check if obj_to_check is a parent of observer in the parent hierarchy of observer. Use this function to avoid circular dependencies. <br/></td></tr>
<tr class="memitem:a4fc9ef22d0006bcf14be59836d4f896e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a4fc9ef22d0006bcf14be59836d4f896e">isSupportedType</a> (const QString &amp;meta_type, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *observer)</td></tr>
<tr class="memdesc:a4fc9ef22d0006bcf14be59836d4f896e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a meta_type is supported by an observer. Note that an observer must have a subject type filter which knows about the type in order for the function to return true.  <a href="#a4fc9ef22d0006bcf14be59836d4f896e"></a><br/></td></tr>
<tr class="memitem:a8e71fd63d862efe1d68620f14e4663f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e71fd63d862efe1d68620f14e4663f2"></a>
static QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a8e71fd63d862efe1d68620f14e4663f2">objectDeletionPolicyToString</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a> object_deletion_policy)</td></tr>
<tr class="memdesc:a8e71fd63d862efe1d68620f14e4663f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a string associated with a specific ObjectDeletionPolicy. <br/></td></tr>
<tr class="memitem:a1dec8af2c6b47a22b7eea343960929d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dec8af2c6b47a22b7eea343960929d5"></a>
static QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1dec8af2c6b47a22b7eea343960929d5">objectOwnershipToString</a> (<a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">ObjectOwnership</a> ownership)</td></tr>
<tr class="memdesc:a1dec8af2c6b47a22b7eea343960929d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a string associated with a specific ObjectOwnership. <br/></td></tr>
<tr class="memitem:a99b27303ae8bc9879058e2f5cb775abb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99b27303ae8bc9879058e2f5cb775abb"></a>
static QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a99b27303ae8bc9879058e2f5cb775abb">observerList</a> (QList&lt; QPointer&lt; QObject &gt; &gt; &amp;object_list)</td></tr>
<tr class="memdesc:a99b27303ae8bc9879058e2f5cb775abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns all the observers in a QList&lt;QObject*&gt; input list. <br/></td></tr>
<tr class="memitem:af9d48fd17492d42adce3cb68399e3741"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af9d48fd17492d42adce3cb68399e3741">parentCount</a> (const QObject *obj)</td></tr>
<tr class="memdesc:af9d48fd17492d42adce3cb68399e3741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to get the number of observers observing the specified object. Thus the number of parents of this object.  <a href="#af9d48fd17492d42adce3cb68399e3741"></a><br/></td></tr>
<tr class="memitem:aa15c4b08b05263b3d54b304e92101d28"><td class="memItemLeft" align="right" valign="top">static QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa15c4b08b05263b3d54b304e92101d28">parentReferences</a> (const QObject *obj)</td></tr>
<tr class="memdesc:aa15c4b08b05263b3d54b304e92101d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to get the a list of parent observers for this object.  <a href="#aa15c4b08b05263b3d54b304e92101d28"></a><br/></td></tr>
<tr class="memitem:a4aaaa36d219daa4d7429c61438de2178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aaaa36d219daa4d7429c61438de2178"></a>
static <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a4aaaa36d219daa4d7429c61438de2178">stringToAccessMode</a> (const QString &amp;access_mode_string)</td></tr>
<tr class="memdesc:a4aaaa36d219daa4d7429c61438de2178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the AccessMode associated with a string. <br/></td></tr>
<tr class="memitem:ac5b0ca883aab9a25baa3a9cc819e6f50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b0ca883aab9a25baa3a9cc819e6f50"></a>
static <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac5b0ca883aab9a25baa3a9cc819e6f50">stringToAccessModeScope</a> (const QString &amp;access_mode_scope_string)</td></tr>
<tr class="memdesc:ac5b0ca883aab9a25baa3a9cc819e6f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the AccessModeScope associated with a string. <br/></td></tr>
<tr class="memitem:a6274f717b8d651bc0270b884418b59de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6274f717b8d651bc0270b884418b59de"></a>
static <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a6274f717b8d651bc0270b884418b59de">stringToObjectDeletionPolicy</a> (const QString &amp;object_deletion_policy_string)</td></tr>
<tr class="memdesc:a6274f717b8d651bc0270b884418b59de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the ObjectDeletionPolicy associated with a string. <br/></td></tr>
<tr class="memitem:acabf7085540c06d1558868c0cb5df841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acabf7085540c06d1558868c0cb5df841"></a>
static <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">ObjectOwnership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acabf7085540c06d1558868c0cb5df841">stringToObjectOwnership</a> (const QString &amp;ownership_string)</td></tr>
<tr class="memdesc:acabf7085540c06d1558868c0cb5df841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the ObjectOwnership associated with a string. <br/></td></tr>
<tr class="inherit_header pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable')"><img src="closed.png" alt="-"/>&nbsp;Static Public Member Functions inherited from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html">Qtilities::Core::Interfaces::IExportable</a></td></tr>
<tr class="memitem:ad6b1d9b5b6d7db5f8ca1a7c838dd3b2c inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6b1d9b5b6d7db5f8ca1a7c838dd3b2c"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#ad6b1d9b5b6d7db5f8ca1a7c838dd3b2c">duplicateInstance</a> (<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html">IExportable</a> *obj, QString *error_msg=0, int properties_to_copy=0, ExportResultFlags *result_flags=0)</td></tr>
<tr class="memdesc:ad6b1d9b5b6d7db5f8ca1a7c838dd3b2c inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an easy to use template based implementation of <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a53663f6696474715cb81d8e0af09157a" title="Function which will create a duplicate (copy) of this object.">IExportable::duplicate()</a>.  <a href="#ad6b1d9b5b6d7db5f8ca1a7c838dd3b2c"></a><br/></td></tr>
<tr class="memitem:acb6447e913066d55f4855a75f89d8049 inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb6447e913066d55f4855a75f89d8049"></a>
static QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acb6447e913066d55f4855a75f89d8049">exportModeToString</a> (<a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830e">ExportMode</a> export_mode)</td></tr>
<tr class="memdesc:acb6447e913066d55f4855a75f89d8049 inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns a string associated with a specific ExportMode. <br/></td></tr>
<tr class="memitem:a063c294f8b1e101b0b2fe96058c0567d inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a063c294f8b1e101b0b2fe96058c0567d"></a>
static <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a0b511edb6513a9014e5d0c033c64830e">ExportMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a063c294f8b1e101b0b2fe96058c0567d">stringToExportMode</a> (const QString &amp;export_mode_string)</td></tr>
<tr class="memdesc:a063c294f8b1e101b0b2fe96058c0567d inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which returns the ExportMode associated with a string. <br/></td></tr>
<tr class="memitem:ab4e5d47109c148bb1319c0ad5dc99d1f inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#ab4e5d47109c148bb1319c0ad5dc99d1f">validateQtilitiesExportVersion</a> (<a class="el" href="namespace_qtilities.html#a46a5ca954966c57c74662ac6e6d8aa25">Qtilities::ExportVersion</a> export_version, <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_task.html">ITask</a> *task=0)</td></tr>
<tr class="memdesc:ab4e5d47109c148bb1319c0ad5dc99d1f inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a5d2012183839898b0a9dd97a3d2d55c7" title="Returns the export version currently used by all Qtilities classes.">exportVersion()</a> against the supported Qtilities export versions for the current Qtilities version.  <a href="#ab4e5d47109c148bb1319c0ad5dc99d1f"></a><br/></td></tr>
<tr class="memitem:a2438e20e806768ce726ed5523dbc80b2 inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acd6f0b0cb325ed46704160377b51d045">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a2438e20e806768ce726ed5523dbc80b2">validateQtilitiesImportVersion</a> (<a class="el" href="namespace_qtilities.html#a46a5ca954966c57c74662ac6e6d8aa25">Qtilities::ExportVersion</a> import_version, <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_task.html">ITask</a> *task=0)</td></tr>
<tr class="memdesc:a2438e20e806768ce726ed5523dbc80b2 inherit pub_static_methods_class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a5d2012183839898b0a9dd97a3d2d55c7" title="Returns the export version currently used by all Qtilities classes.">exportVersion()</a> against the supported Qtilities import versions for the current Qtilities version.  <a href="#a2438e20e806768ce726ed5523dbc80b2"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac30b68d15d67ac9a8a0b581aabd508c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac30b68d15d67ac9a8a0b581aabd508c4">setFactoryData</a> (<a class="el" href="class_qtilities_1_1_core_1_1_instance_factory_info.html">InstanceFactoryInfo</a> factory_data)</td></tr>
<tr class="memdesc:ac30b68d15d67ac9a8a0b581aabd508c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory data which is necessary to reconstruct this observer.  <a href="#ac30b68d15d67ac9a8a0b581aabd508c4"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The observer class is an extended implementation of an observer in the subject-observer pattern. </p>
<p>The observer class provides a powerful implementation of the subject - observer programming pattern. The observer class is the observer in this implementation (as the name suggests) and any QObject based class can be a subject. One way to think about an observer is to think of it as a context in your application to which certain subjects can be attached or detached. An example of such a context is the observer which manages plugins in the Qtilities extension system. When plugins are loaded they are attached to this context and become visible in the list of loaded plugins. Another example would be different instances of a scripting engine. When new objects are created inside the scripting engine they exist in that context. It can then for example be possible to have multiple scripting engines within the same application, where different objects belongs to different script engines or are shared between the engines using Observers.</p>
<p>The example below shows how to create your first observer class and attach objects to it.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer:</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects:</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers:</span></div>
<div class="line">observerA-&gt;attachSubject(object1);</div>
<div class="line">observerA-&gt;attachSubject(object2);</div>
</div><!-- fragment --><h1><a class="anchor" id="observer_displaying"></a>
Displaying the context of an Observer</h1>
<p>One of the original goals of the observer implementation was to make it easy, in fact very easy to display the contents of any <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> context. For this purpose the <a class="el" href="class_qtilities_1_1_core_gui_1_1_observer_widget.html" title="The ObserverWidget class provides a ready-to-use widget to display information about a specific obser...">Qtilities::CoreGui::ObserverWidget</a> class was created which allows you to display the contents of an observer context using only a couple lines of code.</p>
<p>For example: </p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer:</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects:</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers:</span></div>
<div class="line">observerA-&gt;attachSubject(object1);</div>
<div class="line">observerA-&gt;attachSubject(object2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Display the observer context:</span></div>
<div class="line">ObserverWidget observerWidget(observerA);</div>
<div class="line">observerWidget.show();</div>
</div><!-- fragment --><p>Observer widgets are very powerful and observers can specify display hints to views that display their contents using the <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">Qtilities::Core::ObserverHints</a> class. This interaction is a topic on its own and the <a class="el" href="page_observer_widgets.html">Observer Widgets</a> page discusses this in detail. <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> widgets supports both Table and Tree views and the <a class="el" href="class_qtilities_1_1_core_gui_1_1_tree_node.html" title="The TreeNode class is a node in a tree which can have items attached to it and can also be attached t...">Qtilities::CoreGui::TreeNode</a> class is a subclass of observer that makes building of trees using observer easier. The next section describes such trees in more detail.</p>
<h1><a class="anchor" id="observer_trees"></a>
Observer Trees</h1>
<p>Since an observer is able to manage any QObject based class, it is also capable of observing other observers. This feature allows us to build complex hierarchical tree data structures very easily with the only requirements that leaf nodes in our trees must inherit QObject. Using observer widgets you can easily display and tree data structure that you have created and you can even make dot graphs of your tree structures using <a class="el" href="class_qtilities_1_1_core_1_1_observer_dot_writer.html" title="The ObserverDotWriter class generate dot scripts to create dot graphs for an observer tree...">ObserverDotWriter</a>.</p>
<p>Lets look at a simple observer tree structure and the functions provided by observer:</p>
<div class="image">
<img src="observer_tree_classification.jpg" alt="observer_tree_classification.jpg"/>
<div class="caption">
Observer Trees</div></div>
<p> In the above tree <code>Root</code>, <code>A</code> and <code>B</code> are all observers with <code>1-4</code> being any QObject based classes. On the <code>Root</code> observer it is possible to access its subjects using functions on observer that start with <code>subject</code>. For example: <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aabf6283727ab569ea25ba59f110270d2" title="Returns the number of subjects currently observed by the observer.">subjectCount()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a71f8495b3d5a6c5aa7aada671000c26d" title="Returns the observer&#39;s subject limit.">subjectLimit()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a31484604f7def829d78121ac9f8d323e" title="Returns the subject reference at a given position.">subjectAt()</a> etc. Thus these functions allow you to access the objects directly underneath an observer. On the other hand, function starting with <code>tree</code> allow you to operate on the complete tree underneath an observer. For example: <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aba45614f222c4b6d990ad1a156946efa" title="Function to get the number of children under the specified observer.">treeCount()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a5163a7a6ec3ce95190fe23fb75c183c6" title="Function to get a QObject reference at a specific location in the tree underneath this observer...">treeAt()</a> etc.</p>
<p>Qtilities provides the <a class="el" href="class_qtilities_1_1_core_1_1_subject_iterator.html" title="An non-const iterator which iterates throught the subjects of an Observer.">SubjectIterator</a> and <a class="el" href="class_qtilities_1_1_core_1_1_tree_iterator.html" title="An iterator which iterates through an Observer tree (thus also Qtilities::CoreGui::TreeNode).">TreeIterator</a> iterators which allows you to iterate over different parts of the tree structure underneath an observer.</p>
<p>A common request by Qt developers is the ability to easily create and display data based on arbitrary tree structures to users, and to easily interact with users through these trees. It is of course doable using Qt's QAbstractItemModel but its not a trivial tasks and can take time to get right. Qtilities attempts to provide an easy solution to this request in the form of ready to use classes which allows you to build trees easily. The <a class="el" href="page_tree_structures.html">Building Trees</a> page provides a detailed overview of this solution.</p>
<h1><a class="anchor" id="observer_subject_filters"></a>
Subject filters</h1>
<p>Subject filters are a feature of the observer architecture which allows control over object attachment and detachment, as well as monitoring of properties introduced by the subject filter. For more information on this see the <a class="el" href="page_observers.html#subject_filters">Subject filters</a> section of the <a class="el" href="page_observers.html">Observers</a> page.</p>
<h1><a class="anchor" id="observer_threads"></a>
Observers and threads</h1>
<p>Since observers manage objects which can live in different threads it is important to take care when using observers outside of the GUI thread. The following considerations must be taken into account when using observers in threads outside of the GUI thread and attaching objects to observers that live in different threads:</p>
<ul>
<li>Observers monitor QDynamicPropertyChange events on objects that it manages, and send <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_property_change_event.html" title="The QtilitiesPropertyChangeEvent is an event which is posted to objects to notify them about property...">QtilitiesPropertyChangeEvent</a> events on specific internal Qtilities properties to objects that it manages. Since properties cannot be posted to objects living in other threads, and events cannot be filtered on objects in a different thread, this functionality of observers cannot be used when using threads as specified above. Event filtering is enabled by default, thus if you intend to use observers which manage objects in different threads, disable this using <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>.</li>
<li>When using observer's with naming policy filters installed outside of the GUI thread, make sure you don't use the <a class="el" href="class_qtilities_1_1_core_gui_1_1_naming_policy_filter.html#adab2b25c4784d58c0e220f2bfd4bbd2cac263a4c2580d3d63bca403f99f1a6cf3">Qtilities::CoreGui::NamingPolicyFilter::PromptUser</a> resolution policy since it will attempt to construct a QWidget under specific circumstances and you application will crash.</li>
</ul>
<p><a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> by itself is not thread-safe.</p>
<h1><a class="anchor" id="observer_under_the_hood"></a>
Under The Hood: How observers work behind the scenes.</h1>
<p>From a user perspective the observer API attempts to hide the complexities of how object management is done. Behind the scenes there is a lot that is happening and lots of complex features that allows you to customize the way you use observers. The <a class="el" href="page_observers.html">Observers</a> article is a good place to start exploring these details. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a62e08632625c83703a4e5864ff83f374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">Qtilities::Core::Observer::AccessMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible access modes of the observer. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0f358e1fd5410c64067c687691947ea3" title="Function to set the observer&#39;s access mode. Set the access mode after construction. When subclassing Observer, set it in your constructor.">setAccessMode()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1fb93511941be6fbf65b6faf63f9013a" title="Function to get the observer&#39;s access mode.">accessMode()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a62e08632625c83703a4e5864ff83f374ad4cbe6cefcc410de83160b8675e5c767"></a>FullAccess</em>&nbsp;</td><td>
<p>All observer operations are available to the user (Attachment, Detachment etc.). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a62e08632625c83703a4e5864ff83f374a46bfb7915468343fe9d3e4140bb707a5"></a>ReadOnlyAccess</em>&nbsp;</td><td>
<p>The observer is read only to the user. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a62e08632625c83703a4e5864ff83f374a1d318f6e15293b4c205f798533ef979d"></a>LockedAccess</em>&nbsp;</td><td>
<p>The observer is read only and locked. Item views presenting this observer to the user will respect the LockedAccess mode and will not display the contents of the observer to the user. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a62e08632625c83703a4e5864ff83f374a22e659b9ebb954253f023c080ea90122"></a>InvalidAccess</em>&nbsp;</td><td>
<p>An invalid access mode. This access mode is returned in functions where the access mode is requested for a category that does not exist, for example <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0c11e0ee305e0839de72363d97374e30" title="Returns the access mode for a specific category.">categoryAccessMode()</a>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a431b95290ff04ce9b1ea81f28924bf47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">Qtilities::Core::Observer::AccessModeScope</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The access mode scope of the observer. </p>
<p>When using categories in an observer, access modes can be set for each individual category. Categories which does not have access modes set will use the global access mode. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0f358e1fd5410c64067c687691947ea3" title="Function to set the observer&#39;s access mode. Set the access mode after construction. When subclassing Observer, set it in your constructor.">setAccessMode()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a546182e85f9c9800adb6eae244aa9412" title="Function to set the observer&#39;s access mode scope.">setAccessModeScope()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b9134f8702c6b25ea62d6bc75efac89" title="Function to return the access mode scope of the observer.">accessModeScope()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a431b95290ff04ce9b1ea81f28924bf47a6e59b53e8899539a78f0a97839e8bc58"></a>GlobalScope</em>&nbsp;</td><td>
<p>The global access mode is used for all categories when categories are used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a431b95290ff04ce9b1ea81f28924bf47a656444c151a84d9554640b44bebb08ac"></a>CategorizedScope</em>&nbsp;</td><td>
<p>Access modes are category specific. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Qtilities::Core::Observer::EvaluationResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumeration is used to return results when validating attachment and detachment of subjects. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a966cb6090447164d56e7cf8d1b829ff7" title="A function which checks if the new object can be attached to the observer. This function also validat...">canAttach()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af6ef91471ac2abb84f772c78bbb6fd31" title="A function which checks if the object can be detached from the observer. This function also validates...">canDetach()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7ac062904864836fbbef1b690c18abd75e"></a>Allowed</em>&nbsp;</td><td>
<p>Indicates that the attachment/detachment operation will be valid. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7a75fb8e893b48238d84828f6824b06de8"></a>Conditional</em>&nbsp;</td><td>
<p>Indicates that the attachment/detachment operation's validity will be dependent on the user input. An example of this is when the object's name is not valid in the context and the naming policy filter is set to prompt the user for the action to take (Reject, Rename etc.). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7af22010e703a1e8b2488106ca4a386c1c"></a>Rejected</em>&nbsp;</td><td>
<p>Indicates that the attachment/detachment operation will be invalid. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7a02a3051a47674b9c3154ae8f65b4ff15"></a>IsParentObserver</em>&nbsp;</td><td>
<p>Only used during detachment. Indicates that the observer is the parent of the object. This result takes priority over the other possible results. The use case is where the Object Manager attempts to move objects between observers. When attempting to move objects between two observers it will not move subjects which returns this during their detachment validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acf13e78d10a43dd5424a563cca4b6ca7a943757e4b499298101e5f5425f15a5c1"></a>LastScopedObserver</em>&nbsp;</td><td>
<p>Only used during detachment. Indicates that the observer is the last scoped parent of the object. This result takes priority over the other possible results except IsParentObserver. The use case is where the Object Manager attempts to move objects between observers. When attempting to move objects between two observers it will not move subjects which returns this during their detachment validation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ac10bd670cc699870807b5b684461ba8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">Qtilities::Core::Observer::ObjectDeletionPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible deletion methods that <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> can use when deleting objects attached to it. </p>
<p>By default DeleteLater is used, thus it is safe when deleting objects living in threads other than the observer itself. One drawback of using DeleteLater is that the ObserverWidgets viewing your <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> will only be updated when your object is actually deleted. This can cause your views to take a while to be updated. If you are sure that your objects live in the same thread as the observer you should use DeleteImmediately to avoid this behaviour.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a67e214fac1968630563da51e0c661148" title="Function to set the observer&#39;s object deletion policy.">setObjectDeletionPolicy()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac10bd670cc699870807b5b684461ba8bae7f040d2afa882212c33c17464277bee"></a>DeleteImmediately</em>&nbsp;</td><td>
<p>When subjects are deleted by this observer, the normal <code>delete</code> operator is used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac10bd670cc699870807b5b684461ba8bac605f0218c0969eadfcfc1f7cf20668f"></a>DeleteLater</em>&nbsp;</td><td>
<p>When subjects are deleted by this observer, deleteLater() are called on them. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Qtilities::Core::Observer::ObjectOwnership</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible ownerships with which subjects can be attached to an observer. </p>
<p>See the <a class="el" href="page_observers.html#object_lifetimes">Object lifetimes: Managing object lifetimes using observers</a> section of the <a class="el" href="page_observers.html">Observers</a> article for a detailed discussion. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715"></a>ManualOwnership</em>&nbsp;</td><td>
<p>Manual ownership means that the object won't be managed by the observer, thus the ownership will be managed the normal Qt way. If <code>parent()</code> = 0, it will not be managed, if <code>parent()</code> is an QObject, the subject will be deleted when its parent is deleted.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer A&quot;</span>,<span class="stringliteral">&quot;My first observer&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">object1-&gt;setObjectName(<span class="stringliteral">&quot;Object 1&quot;</span>);</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line">object2-&gt;setObjectName(<span class="stringliteral">&quot;Object 2&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>);</div>
<div class="line">observerA-&gt;attachSubject(object2,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete observers</span></div>
<div class="line"><span class="keyword">delete</span> observerA;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the objects</span></div>
<div class="line"><span class="keywordflow">if</span> (object1) {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (object2) {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>After deleting the two observers in the example above, <code>object1</code> and <code>object2</code> will still be valid, thus they will not be deleted. Note that subjects are attached to observers using manual ownership by default. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17ea27e56daee599802358d1b29381e2c5d0"></a>AutoOwnership</em>&nbsp;</td><td>
<p>Auto ownership means that the observer will automatically decide how to manage the subject. The observer checks if the object already has a parent(), if so <code>ManualOwnership</code> is used. If no <code>parent()</code> is specified yet, the observer will attach the subject using <code>ObserverScopeOwnership</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer A&quot;</span>,<span class="stringliteral">&quot;My first observer&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">object1-&gt;setObjectName(<span class="stringliteral">&quot;Object 1&quot;</span>);</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line">object2-&gt;setObjectName(<span class="stringliteral">&quot;Object 2&quot;</span>);</div>
<div class="line">QPointer&lt;QObject&gt; parentObject = <span class="keyword">new</span> QObject();</div>
<div class="line">object2-&gt;setParent(parentObject);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea27e56daee599802358d1b29381e2c5d0">Observer::AutoOwnership</a>);</div>
<div class="line">observerA-&gt;attachSubject(object2,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea27e56daee599802358d1b29381e2c5d0">Observer::AutoOwnership</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete observers</span></div>
<div class="line"><span class="keyword">delete</span> observerA;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the objects</span></div>
<div class="line"><span class="keywordflow">if</span> (object1) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (object2) {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>Since <code>object2</code> has a parent, it will be attached using <code>ManualOwnership</code> and <code>ObserverScopeOwnership</code> will be used for <code>object1</code>. Therefore after deleting the observers, <code>object1</code> will be null (see observer_scope_ownership) and <code>object2</code> will still be valid. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17eab8616ed1c4b4bad93132614d2125c2f1"></a>SpecificObserverOwnership</em>&nbsp;</td><td>
<p>The observer becomes the parent of the subject (by calling setParent() on the object). That is, when the observer is deleted, the subject is also deleted.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer A&quot;</span>,<span class="stringliteral">&quot;My first observer&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">object1-&gt;setObjectName(<span class="stringliteral">&quot;Object 1&quot;</span>);</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line">object2-&gt;setObjectName(<span class="stringliteral">&quot;Object 2&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eab8616ed1c4b4bad93132614d2125c2f1">Observer::SpecificObserverOwnership</a>);</div>
<div class="line">observerA-&gt;attachSubject(object2,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eab8616ed1c4b4bad93132614d2125c2f1">Observer::SpecificObserverOwnership</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete observer</span></div>
<div class="line"><span class="keyword">delete</span> observerA;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the objects</span></div>
<div class="line"><span class="keywordflow">if</span> (object1) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (object2) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Both objects will become null after the observers are deleted since <code>observerA</code> becomes the specific parent of both objects.</p>
<dl class="section note"><dt>Note:</dt><dd>QWidget's parent must be another QWidget, thus these rules don't apply to QWidgets. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e"></a>ObserverScopeOwnership</em>&nbsp;</td><td>
<p>The object must have at least one <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> parent at any time. That is, when the object is attached to multiple observers, it will stay valid until it goes out of scope. This can happen because all its observer parents gets deleted, or it is detached from all contexts.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer</span></div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer A&quot;</span>,<span class="stringliteral">&quot;My first observer&quot;</span>);</div>
<div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>* observerB = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer B&quot;</span>,<span class="stringliteral">&quot;My second observer&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">object1-&gt;setObjectName(<span class="stringliteral">&quot;Object 1&quot;</span>);</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject();</div>
<div class="line">object2-&gt;setObjectName(<span class="stringliteral">&quot;Object 2&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e">Observer::ObserverScopeOwnership</a>);</div>
<div class="line">observerA-&gt;attachSubject(object2,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e">Observer::ObserverScopeOwnership</a>);</div>
<div class="line">observerB-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e">Observer::ObserverScopeOwnership</a>);</div>
<div class="line">observerB-&gt;attachSubject(object2,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17eaf484cd3398ca2a5cd5d6a6c0d3f6be0e">Observer::ObserverScopeOwnership</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete observer A</span></div>
<div class="line"><span class="keyword">delete</span> observerA;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the objects</span></div>
<div class="line"><span class="keywordflow">if</span> (object1) {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (object2) {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete observer B</span></div>
<div class="line"><span class="keyword">delete</span> observerB;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the objects</span></div>
<div class="line"><span class="keywordflow">if</span> (object1) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (object2) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Both objects will still be valid after deleting <code>observerA</code> since it they are still visible in the scope of <code>observerB</code>. After <code>observerB</code> is deleted both objects will be null.</p>
<dl class="section note"><dt>Note:</dt><dd>QWidget's parent must be another QWidget, thus these rules don't apply to QWidgets. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aee321cdb07667b5fe20d03a59e9ff17ea97aee1aa43bfdc794423576e2c32598e"></a>OwnedBySubjectOwnership</em>&nbsp;</td><td>
<p>The observer is dependent on the subject, thus the subject effectively owns the observer. When the subject is deleted, the observer is also deleted. When the observer is deleted it checks if the subject is attached to any other observers and if not it deletes the subject as well. If the subject is attached to any other observers, the subject is not deleted. When the current ownership of a subject is <code>OwnedBySubjectOwnership</code> and it is attached to more contexts, the new ownership is ignored during attachment to the new contexts. Thus when a subject was attached to a context using <code>OwnedBySubjectOwnership</code> it is attached to all other contexts after that using <code>OwnedBySubjectOwnership</code> as well. On the other hand, when a subject is already attached to one or more observer contexts and it is attached to a new observer using <code>OwnedBySubjectOwnership</code>, the old ownership is kept and the observer only connects the destroyed() signal on the object to its own deleteLater() signal.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the observer</span></div>
<div class="line">QPointer&lt;Observer&gt; observerA = <span class="keyword">new</span> <a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a>(<span class="stringliteral">&quot;Observer A&quot;</span>,<span class="stringliteral">&quot;My first observer&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject();</div>
<div class="line">object1-&gt;setObjectName(<span class="stringliteral">&quot;Object 1&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1,<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97aee1aa43bfdc794423576e2c32598e">Observer::OwnedBySubjectOwnership</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now delete the object</span></div>
<div class="line"><span class="keyword">delete</span> object1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the validity of the observer</span></div>
<div class="line"><span class="keywordflow">if</span> (observerA) {</div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We get here in this example.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example <code>observerA</code> will be deleted as soon as <code>object1</code> is deleted.</p>
<dl class="section note"><dt>Note:</dt><dd>QWidget's parent must be another QWidget, thus these rules don't apply to QWidgets. </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a35b36877048980c1e9acdb1a9ad586ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586ef">Qtilities::Core::Observer::SubjectChangeIndication</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible indications that can be returned when the number of subjects in the observer changes. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0f3a77740427719bdbf77876bb4411c" title="A signal which is emitted when the number of subjects change in this observer context.">numberOfSubjectsChanged()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a35b36877048980c1e9acdb1a9ad586efa579560dabf803bac4460af73537a38b3"></a>SubjectAdded</em>&nbsp;</td><td>
<p>Indicates that subjects were added. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a35b36877048980c1e9acdb1a9ad586efa59cf648266233512ce0182dd53922be3"></a>SubjectRemoved</em>&nbsp;</td><td>
<p>Indicates that subjects were removed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a35b36877048980c1e9acdb1a9ad586efa21bda231f103f0e03d216c07d491eb97"></a>CyclicProcess</em>&nbsp;</td><td>
<p>Indicates that the number of subjects changed during a cyclic process. The subject count can either be less or more than before the cyclic operation. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a24fdba0f7f8bc88ae991d3d4346b5d2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Observer::~Observer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> destructor. </p>
<p>The destructor will delete necesarry objects, thus it will check the ownership of each subject and delete it when it has SpecificObserverOwnership set to this <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, or when it has ObserverScopeOwnership and this is the last observer that it is attached to. Note that the deletion method used depends on the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> of this observer. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1fb93511941be6fbf65b6faf63f9013a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">Qtilities::Core::Observer::AccessMode</a> Qtilities::Core::Observer::accessMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>&#160;</td>
          <td class="paramname"><em>category</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the observer's access mode. </p>
<dl class="section return"><dt>Returns:</dt><dd>The global access mode when category an empty category is used for <code>category</code>. Otherwise the access mode for a specific category. The global access mode is FullAccess by default. When an invalid category (does not exist in this context) is sent <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374a22e659b9ebb954253f023c080ea90122">Observer::InvalidAccess</a> is returned and an error message is printed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b9134f8702c6b25ea62d6bc75efac89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a431b95290ff04ce9b1ea81f28924bf47">AccessModeScope</a> Qtilities::Core::Observer::accessModeScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to return the access mode scope of the observer. </p>
<dl class="section return"><dt>Returns:</dt><dd>The access mode scope. Global by default. </dd></dl>

</div>
</div>
<a class="anchor" id="aa900e73ea3ad2292782a45c11adb2d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::attachSubject </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>import_cycle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will attempt to attach the specified object to the observer. The success of this operation depends on the installed subject filters, as well as the dynamic properties defined for the object to be attached. </p>
<p>When Successful <code>obj</code> will be part of this observer context until it is detached again or deleted.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be attached. </td></tr>
    <tr><td class="paramname">ownership</td><td>The ownership that the observer should use to manage the object. The default is <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>When this function fails and rejectMsg will be populated with an rejection message when valid. </td></tr>
    <tr><td class="paramname">import_cycle</td><td>Indicates if the attachment call was made during an observer import cycle. In such cases the subject filter must not add exportable properties to the object since these properties will be added from the import source. Also, it is not necessary to validate the context in such cases. False by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>True is succesful, false otherwise.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>When <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a> is true, the observer will be installed as an event filter on <code>obj</code>. If you do not want this to happen you can turn it off using <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>. See the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a> function documentation for more information on this. </dd>
<dd>
When obj lives in a different thread than this observer an attempt won't be made to install this observer as an event filter. </dd>
<dd>
When obj-&gt;objectName() is empty, this function will set the object name to the className() of the object.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a5a65d50b41a1f54e66a709d1f3b6291f" title="Will attempt to attach the specified objects to the observer.">attachSubjects()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a65d50b41a1f54e66a709d1f3b6291f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QPointer&lt; QObject &gt; &gt; Qtilities::Core::Observer::attachSubjects </td>
          <td>(</td>
          <td class="paramtype">QList&lt; QObject * &gt;&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>import_cycle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will attempt to attach the specified objects to the observer. </p>
<p>This function will call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a> when it starts and <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> when it is done.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>A list of objects which must be attached. </td></tr>
    <tr><td class="paramname">ownership</td><td>The ownership that the observer should use to manage the object. The default is <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>. </td></tr>
    <tr><td class="paramname">import_cycle</td><td>Indicates if the attachment call was made during an observer import cycle. In such cases the subject filter must not add exportable properties to the object since these properties will be added from the import source. Also, it is not necessary to validate the context in such cases. False by default. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>When this function fails and rejectMsg will be populated with an rejection message when valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A list of objects that was successfully added. Thus if the list has the same amount of items in <code>objects</code>, the operation was succesful on all objects.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa900e73ea3ad2292782a45c11adb2d67" title="Will attempt to attach the specified object to the observer. The success of this operation depends on...">attachSubject()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a237ebcbb90a05f734b2b0e417fdbcef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QPointer&lt; QObject &gt; &gt; Qtilities::Core::Observer::attachSubjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html">ObserverMimeData</a> *&#160;</td>
          <td class="paramname"><em>mime_data_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>import_cycle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will attempt to attach the specified objects in a <a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html" title="The ObserverMimeData stores information about subjects when Qtilities does drag and drops between Obs...">ObserverMimeData</a> object. </p>
<p>This function will call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a> when it starts and <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> when it is done.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be attached. </td></tr>
    <tr><td class="paramname">ownership</td><td>The ownership that the observer should use to manage the object. The default is <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>When this function fails and rejectMsg will be populated with an rejection message when valid. </td></tr>
    <tr><td class="paramname">import_cycle</td><td>Indicates if the attachment call was made during an observer import cycle. In such cases the subject filter must not add exportable properties to the object since these properties will be added from the import source. Also, it is not necessary to validate the context in such cases. False by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A list of objects which was successfully added. Thus if the list has the same amount of items in <code>objects</code>, the operation was succesful on all objects.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa900e73ea3ad2292782a45c11adb2d67" title="Will attempt to attach the specified object to the observer. The success of this operation depends on...">attachSubject()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89aedbcefb1784ae36ff601e7160099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::broadcastModificationStateChangesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if broadcasting of modification state changes are enabled. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa2668fd3c211a83ed33134fb865cda5c" title="This function enables/disables broadcasting of modification state changes Observer.">toggleBroadcastModificationStateChanges()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a966cb6090447164d56e7cf8d1b829ff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Qtilities::Core::Observer::EvaluationResult</a> Qtilities::Core::Observer::canAttach </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Observer::ObjectOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function which checks if the new object can be attached to the observer. This function also validates the attachment operation inside all installed subject filters. Note that this function does not attach it. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to test attachment of. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>Rejection message. If the attachment cannot be done, thus it returns <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7af22010e703a1e8b2488106ca4a386c1c">Observer::Rejected</a>, you can get the reason through this error message. </td></tr>
    <tr><td class="paramname">ownership</td><td>This parameter allows you to specify the ownership to use during attachment. By default <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17ea97ec535efd70401500c9dbbba9e7b715">Observer::ManualOwnership</a>. </td></tr>
    <tr><td class="paramname">silent</td><td>When true the function checks if the attachment can be done without using any dialog boxes. This is usefull when you need to attach subjects in an event filter where showing a dialog is a problem. An example of this is drag/drop operations in ObserverWidgets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abde9962f6bf417750ff12c7efd16b7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Qtilities::Core::Observer::EvaluationResult</a> Qtilities::Core::Observer::canAttach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html">ObserverMimeData</a> *&#160;</td>
          <td class="paramname"><em>mime_data_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function which checks if the objects in the <a class="el" href="class_qtilities_1_1_core_1_1_observer_mime_data.html" title="The ObserverMimeData stores information about subjects when Qtilities does drag and drops between Obs...">ObserverMimeData</a> object can be attached to the observer. This function also validates the attachment operation inside all installed subject filters. Note that this function does not attach it. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_data_object</td><td>The mime data object to test attachment of. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>Rejection message. If the attachment cannot be done, thus it returns <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7af22010e703a1e8b2488106ca4a386c1c">Observer::Rejected</a>, you can get the reason through this error message. </td></tr>
    <tr><td class="paramname">silent</td><td>When true the function checks if the attachment can be done without using any dialog boxes. This is useful when you need to attach subjects in an event filter where showing a dialog is a problem. An example of this is drag/drop operations in ObserverWidgets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6ef91471ac2abb84f772c78bbb6fd31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7">Qtilities::Core::Observer::EvaluationResult</a> Qtilities::Core::Observer::canDetach </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function which checks if the object can be detached from the observer. This function also validates the detachment operation inside all installed subject filters. Note that this function does not detach it. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to test detachment of. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>Rejection message. If the attachment cannot be done, thus it returns <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acf13e78d10a43dd5424a563cca4b6ca7af22010e703a1e8b2488106ca4a386c1c">Observer::Rejected</a>, you can get the reason through this error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c11e0ee305e0839de72363d97374e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">Qtilities::Core::Observer::AccessMode</a> Qtilities::Core::Observer::categoryAccessMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;&#160;</td>
          <td class="paramname"><em>category</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the access mode for a specific category. </p>
<p>If the category does not exist, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374a22e659b9ebb954253f023c080ea90122">Observer::InvalidAccess</a> is returned. </p>

</div>
</div>
<a class="anchor" id="ab26c935b46c6d708cb8e41cdf9c2b2da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::clearExportTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the export task. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a8f2431a878d6baeb23be5560eb2cdc77" title="Sets the task which must be used to log import/export information to.">setExportTask()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#af16b7fe85350bdf566709b3cf8e9fcb7" title="Gets the task which must be used to log import/export information to.">exportTask()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#afec36f616e694596721b32fb7430bc19">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a6caa39610e2107bf127e83f5a94e84ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::containsSubjectWithName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>subject_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::CaseSensitivity&#160;</td>
          <td class="paramname"><em>cs</em> = <code>Qt::CaseSensitive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a subject with the specified name is currently observed by the observer. </p>
<dl class="section note"><dt>Note:</dt><dd>Only depend on this function (where you specify the object using the object's name) when you are sure that objects have unique names. This can be achieved by installing a NamingPolicyFilter in your observer. If names are not unique, the first match of the given subject_name will be used. If you don't care about unique subject names, rather use subjectReference(int ID) to get subject references. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2aa612400862d0659ba0bd36824ff50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::copyHints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">ObserverHints</a> *&#160;</td>
          <td class="paramname"><em>display_hints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to let this observer copy a set of display hints. </p>
<p>This function allows you to copy the hints used by this <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> from a different <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">ObserverHints</a> instance.</p>
<dl class="section note"><dt>Note:</dt><dd>If you call this function on the observer which does not have any <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a417048c7a59f6b87bf580743dc34b06d" title="Function which returns a pointer to the ObserverHints used by this observer.">displayHints()</a> yet (thus <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0" title="Function which constructs hints for this observer.">useDisplayHints()</a> have not been called yet) this function will call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0" title="Function which constructs hints for this observer.">useDisplayHints()</a> before inheriting the hints.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>True if successful, false otherwise.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0" title="Function which constructs hints for this observer.">useDisplayHints()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a417048c7a59f6b87bf580743dc34b06d" title="Function which returns a pointer to the ObserverHints used by this observer.">displayHints()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa00359a136283610161bf2d82a7114e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::dataChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *&#160;</td>
          <td class="paramname"><em>observer</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A signal which is emitted when the data in the observer or the tree underneath it changes. </p>
<p>This signal will be emitted whenever the data of the observer or any subjects in the tree underneath the observer changes.</p>
<p>This will happen when any of the following happens inside the observer context:</p>
<ul>
<li>Activity changes happens.</li>
<li>Names of observers or subjects changes.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>When the data that changed is related to a specific observer context, for example if the activity of all subjects inside a context changed, the observer can be passed as the <code>observer</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>When creating models for observers, this signal should be connected to the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#afa00359a136283610161bf2d82a7114e" title="A signal which is emitted when the data in the observer or the tree underneath it changes...">dataChanged()</a> signal of your model. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f44ef3c1b4f0ca6348a3c507589787f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::deleteAll </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>base_class_name</em> = <code>&quot;QObject&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refresh_views</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to delete all currenlty observed subjects. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_class_name</td><td>Specifies that only items inheriting the specified base class must be deleted. </td></tr>
    <tr><td class="paramname">refresh_views</td><td>Indicates if this function must refresh all observer views when done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adefcba25b55a45bbe0e4f72e4ba0fbb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::detachAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to detach all currently observed subjects. </p>
<p>This function will delete necessary objects, thus it will check the ownership of each subject and delete it when it has SpecificObserverOwnership set to this <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, or when it has ObserverScopeOwnership and this is the last observer that it is attached to. Note that the deletion method used depends on the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> of this observer. </p>

</div>
</div>
<a class="anchor" id="a9eacee75add5520dd269b1ee880e70f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::detachSubject </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will attempt to detach the specified object from the observer. </p>
<p>This function will delete obj if necessary, thus it will check its ownership and delete it when it has SpecificObserverOwnership set to this <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, or when it has ObserverScopeOwnership and this is the last observer that it is attached to. Note that the deletion method used depends on the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> of this observer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be detached. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>When this function fails and rejectMsg will be populated with an rejection message when valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abf06c71688ebaed01c7b621effb04991"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QPointer&lt; QObject &gt; &gt; Qtilities::Core::Observer::detachSubjects </td>
          <td>(</td>
          <td class="paramtype">QList&lt; QObject * &gt;&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString *&#160;</td>
          <td class="paramname"><em>rejectMsg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will attempt to detach the specified object objects in the list from the observer. </p>
<p>This function will delete necessary objects, thus it will check the ownership of each subject and delete it when it has SpecificObserverOwnership set to this <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, or when it has ObserverScopeOwnership and this is the last observer that it is attached to. Note that the deletion method used depends on the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> of this observer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>A list of objects which must be detached. </td></tr>
    <tr><td class="paramname">rejectMsg</td><td>When this function fails and rejectMsg will be populated with an rejection message when valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A list of objects which was successfully detached. </dd></dl>

</div>
</div>
<a class="anchor" id="a417048c7a59f6b87bf580743dc34b06d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">Qtilities::Core::ObserverHints</a> * Qtilities::Core::Observer::displayHints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which returns a pointer to the <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">ObserverHints</a> used by this observer. </p>
<p>If no observer hints are used, 0 is returned.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0" title="Function which constructs hints for this observer.">useDisplayHints()</a>, setDisplayHints() </dd></dl>

</div>
</div>
<a class="anchor" id="a1c355778ad9caa8a9237f192a7a6a12e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::endProcessingCycle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a processing cycle. </p>
<p>Ends a processing cycle started with <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>. The processing cycle will only be stopped when the number of <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> calls matches the number of <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a> calls. If you call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> too many times an error message will be printed using qWarning().</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadcast</td><td>If the number of subjects changed during the processing cycle (thus, since <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a> was called the first time), this function will automatically emit <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0f3a77740427719bdbf77876bb4411c" title="A signal which is emitted when the number of subjects change in this observer context.">numberOfSubjectsChanged()</a> and refreshLayout() when broadcast is true. When false, none of these signals are emitted. Also, if the observer's modification state is true after the processing cycle ended, the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af8729f719113e4e9183f1cf3cbbb2796" title="Implement this function as a signal when implementing the object.">modificationStateChanged()</a> signal will automatically be called when broadcast is true, and not when broadcast is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>When emitting <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0f3a77740427719bdbf77876bb4411c" title="A signal which is emitted when the number of subjects change in this observer context.">numberOfSubjectsChanged()</a> the objects parameter will be empty even when the number of subjects changed.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6" title="Indicates if a processing cycle is active.">isProcessingCycleActive()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ad00a5cdf6c98b5120375cf1185dc31c9" title="Signal which is emitted when this observer exists a processing cycle.">processingCycleEnded()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abc3ba640a0dd9be561c6e0ea25cb5f40" title="Starts a processing cycle.">endTreeProcessingCycle()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_qtilities_1_1_core_gui_1_1_tree_node.html#adb452d75470c26ca7970f246437a1f7b">Qtilities::CoreGui::TreeNode</a>.</p>

</div>
</div>
<a class="anchor" id="abc3ba640a0dd9be561c6e0ea25cb5f40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::endTreeProcessingCycle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a processing cycle. </p>
<p>Same behaviour as startProcessingCyle(), but starts a processing cycle on the complete tree underneath the observer. Thus, processing cycles are started on all observers attached to this observer and those attached to that observer etc. It is important to node that you should use <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abc3ba640a0dd9be561c6e0ea25cb5f40" title="Starts a processing cycle.">endTreeProcessingCycle()</a> when using this function.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acee4989f8b736a0d5971178d49f2bc43" title="Starts a processing cycle.">startTreeProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6" title="Indicates if a processing cycle is active.">isProcessingCycleActive()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9c0d5acccdf0b823df31574d5d37dab9" title="Signal which is emitted when this observer enters a processing cycle.">processingCycleStarted()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_qtilities_1_1_core_gui_1_1_tree_node.html#a1940b69f74309275768434c9088b03cb">Qtilities::CoreGui::TreeNode</a>.</p>

</div>
</div>
<a class="anchor" id="a3651ff7e55eefa906c3c28b9f52735c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::eventFilter </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QEvent *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event filter filters property change events on all subjects. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a87d841260596abf11e47d4e66a35ecc0" title="This function enables/disables delivery of QtilitiesPropertyChangeEvents on objects when property cha...">toggleQtilitiesPropertyChangeEvents()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac014f0fe013c48b15ad9c9fe6291e56c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Interfaces::IExportable::ExportResultFlags Qtilities::Core::Observer::exportBinary </td>
          <td>(</td>
          <td class="paramtype">QDataStream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows exporting to a QDataStream. </p>
<p>See <a class="el" href="page_serializing_overview.html">Serializing Qtilities Data Types Overview</a> for more information about the expected output format.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to the QDataStream to which the object's information must be appended is provided. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#ae6a796b4a4e9dff1c53564cefe4c158a">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a3c4b4ca4a8c6e68cc20e489b78eece98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Interfaces::IExportable::ExportResultFlags Qtilities::Core::Observer::exportXml </td>
          <td>(</td>
          <td class="paramtype">QDomDocument *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QDomElement *&#160;</td>
          <td class="paramname"><em>object_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows exporting to an XML document. A reference to the QDomElement to which the object's information must be added is provided, along with a reference to the QDomDocument. </p>
<p>See <a class="el" href="page_serializing_overview.html">Serializing Qtilities Data Types Overview</a> for more information about the expected output format. </p>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a7b0b7037036825df0a2f5a42e0932e1c">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a57ed14bed73159d5281a75b1e64fe599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariant Qtilities::Core::Observer::getMultiContextPropertyValue </td>
          <td>(</td>
          <td class="paramtype">const QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which will get the value of a <a class="el" href="class_qtilities_1_1_core_1_1_multi_context_property.html" title="A MultiContextProperty provides a property which has different values in different contexts...">MultiContextProperty</a> based dynamic property, and not the observer property itself. </p>
<p>If the property_name does not refer to a shared property, the observer context of the observer on which this function is called will be used to define the observer context for which this function will get the property's value. If the <code>property_name</code> refers to a shared property, the shared property's value will be returned. </p>

</div>
</div>
<a class="anchor" id="a7b65f6056401863d92b197e82e707752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Interfaces::IExportable::ExportResultFlags Qtilities::Core::Observer::importBinary </td>
          <td>(</td>
          <td class="paramtype">QDataStream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QList&lt; QPointer&lt; QObject &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>import_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For subjects, the sequence in which the object reconstruction happens is as follows:</p>
<ul>
<li>Construct object and set object name according to factory data.</li>
<li>Attach object.</li>
<li>Set object category if it exists.</li>
<li>Call the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa133ba40b8048e87bc6a80d4a0af45e2">importXml()</a> function on the object's IExportable implementation.</li>
<li>Set object activity.</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd>This function does not call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#adefcba25b55a45bbe0e4f72e4ba0fbb0" title="Function to detach all currently observed subjects.">detachAll()</a> before doing the import. </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#acb059cb85e3895d5466f0e398e185ba0">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="aa133ba40b8048e87bc6a80d4a0af45e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Interfaces::IExportable::ExportResultFlags Qtilities::Core::Observer::importXml </td>
          <td>(</td>
          <td class="paramtype">QDomDocument *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QDomElement *&#160;</td>
          <td class="paramname"><em>object_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QList&lt; QPointer&lt; QObject &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>import_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For subjects, the sequence in which the object reconstruction happens is as follows:</p>
<ul>
<li>Construct object and set object name according to factory data.</li>
<li>Attach object.</li>
<li>Set object category if it exists.</li>
<li>Call the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa133ba40b8048e87bc6a80d4a0af45e2">importXml()</a> function on the object's IExportable implementation.</li>
<li>Set object activity.</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd>This function does not call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#adefcba25b55a45bbe0e4f72e4ba0fbb0" title="Function to detach all currently observed subjects.">detachAll()</a> before doing the import. </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a8d92f1fa282a71a41ceed951e217707a">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="ad6c48e66ac4dadb59760923d7915abc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::installSubjectFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html">AbstractSubjectFilter</a> *&#160;</td>
          <td class="paramname"><em>subject_filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a new subject filter. </p>
<p>The observer will take ownership of the subject filter object and delete it in its constructor. Subject filters can only be installed when the observer has no subjects attached to it.</p>
<p>Subject filter names are unique in the context of an observer. This ensures that two filters of the same type cannot be installed in the same context. This function will check that the filterName() of <code>subject_filter</code> is unique and then add it. If it is not, the function will fail. </p>

</div>
</div>
<a class="anchor" id="a54fbff815e7f257ae8172656592df8df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_instance_factory_info.html">Qtilities::Core::InstanceFactoryInfo</a> Qtilities::Core::Observer::instanceFactoryInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The instance factory information which must be used when the exported object is reconstructed during an import. </p>
<p>For more information see <a class="el" href="page_factories.html#factory_iexportable_relationship">The IExportable interface, what does it have to do with factories?</a>. </p>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a67c14d92cab82f44d81025b2784db060">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a883e9ac9aba9b523fab8d6c72b762bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::isProcessingCycleActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a processing cycle is active. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4fc9ef22d0006bcf14be59836d4f896e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::isSupportedType </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>meta_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to check if a meta_type is supported by an observer. Note that an observer must have a subject type filter which knows about the type in order for the function to return true. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="struct_qtilities_1_1_core_1_1_subject_type_info.html" title="The SubjectTypeInfo structure is used to define subject types.">Qtilities::Core::SubjectTypeInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2881fecc87616d51f2e222f94b522458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::layoutChanged </td>
          <td>(</td>
          <td class="paramtype">QList&lt; QPointer&lt; QObject &gt; &gt;&#160;</td>
          <td class="paramname"><em>new_selection</em> = <code>QList&lt;&#160;QPointer&lt;&#160;QObject&#160;&gt;&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A signal which is emitted when the layout of the observer or the tree underneath it changes. </p>
<p>This signal will be emitted whenever the layout of an observer or the tree underneath it changes.</p>
<p>This will happen when any of the following happens inside the observer context:</p>
<ul>
<li>Number of subjects changes in an observer context which is part of the tree.</li>
<li><a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> hints changes. Since observer hints define how item models displays (lays out) an observer context, changes to these hints will trigger the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a> signal.</li>
<li>Replace operations triggered by NamingPolicyFilter filters.</li>
<li><a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> access mode and access mode scope changes.</li>
<li>Subject access mode changes.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_selection</td><td>The new desired selection in any views that are refreshed due to the layout changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>When creating models for observers, this signal should be connected to the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a> signal of your model for tree models. For table models connecting to <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0f3a77740427719bdbf77876bb4411c" title="A signal which is emitted when the number of subjects change in this observer context.">numberOfSubjectsChanged()</a> should be enough. </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1fb93511941be6fbf65b6faf63f9013a" title="Function to get the observer&#39;s access mode.">accessMode()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b9134f8702c6b25ea62d6bc75efac89" title="Function to return the access mode scope of the observer.">accessModeScope()</a>, <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html#ad4917ea5eacd8043d207593556463afc" title="Object Access Mode Property.">Qtilities::Core::Properties::qti_prop_ACCESS_MODE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8729f719113e4e9183f1cf3cbbb2796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::modificationStateChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_modified</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this function as a signal when implementing the object. </p>
<p>Because this interface does not use the Q_OBJECT macro, you cannot connect to this signal directly. Instead you need to connect to the signal on the base object implementing this interface as follows:</p>
<div class="fragment"><div class="line">connect(iface-&gt;objectBase(),SIGNAL(<a class="code" href="class_qtilities_1_1_core_1_1_observer.html#af8729f719113e4e9183f1cf3cbbb2796" title="Implement this function as a signal when implementing the object.">modificationStateChanged</a>(<span class="keywordtype">bool</span>)),SLOT(yourSlot(<span class="keywordtype">bool</span>)));</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ace1689196aa9433e66b8126585572a68">Qtilities::Core::Interfaces::IModificationNotifier</a>.</p>

</div>
</div>
<a class="anchor" id="aab01469a6574cad08f38247f25c174fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Qtilities::Core::Observer::monitoredProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a QStringList with the names of all the properties which are monitored by this observer. </p>
<p>Monitored properties are properties that are monitored for changes by the event filter of the observer and <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html#a6260e9f4a700b4375757f067c70116c0" title="Function which should react to QDynamicPropertyChangeEvents on properties which are reserved by the s...">Qtilities::Core::AbstractSubjectFilter::handleMonitoredPropertyChange()</a> functions on all subject filters installed in the observer context. The observer's event filter will automatically route the changes to monitored properties of installed subject filters to the correct subject filters.</p>
<p>When property changes are valid, the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaeef96b6b380c12667adb82c48f7cdc2" title="A signal which is emitted as soon as a monitored property of the observer or any of the installed sub...">monitoredPropertyChanged()</a> signal is emitted as soon as the property change is completed.</p>
<dl class="section note"><dt>Note:</dt><dd>The list of monitored properties includes monitored properties of any installed subject filters.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaeef96b6b380c12667adb82c48f7cdc2" title="A signal which is emitted as soon as a monitored property of the observer or any of the installed sub...">monitoredPropertyChanged()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abecf544807a89ac1e4150bb08098b254" title="A signal which is emitted as soon as an property change event is filtered.">propertyChangeFiltered()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaeef96b6b380c12667adb82c48f7cdc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::monitoredPropertyChanged </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QList&lt; QObject * &gt;&#160;</td>
          <td class="paramname"><em>objects</em> = <code>QList&lt;&#160;QObject&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A signal which is emitted as soon as a monitored property of the observer or any of the installed subject filters changed. </p>
<p>This signal is usefull when you want to monitor a specific object. This can be done in two ways:</p>
<ul>
<li>By filtering the <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_property_change_event.html" title="The QtilitiesPropertyChangeEvent is an event which is posted to objects to notify them about property...">QtilitiesPropertyChangeEvent</a> on the object. However events can only be delivered to objects in the same thread. Therefore, if the object you are interested in is in a different thread than the observer context, this will not work.</li>
<li>The alternative is to connect to this signal and check if the object you are interested in is in the list of objects on which the property changed.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">property_name</td><td>The name of the property which changed. </td></tr>
    <tr><td class="paramname">objects</td><td>The objects on which the property changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aab01469a6574cad08f38247f25c174fd" title="This function returns a QStringList with the names of all the properties which are monitored by this ...">monitoredProperties()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abecf544807a89ac1e4150bb08098b254" title="A signal which is emitted as soon as an property change event is filtered.">propertyChangeFiltered()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2aa5b3be769ae0b5a6b0acef59070fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Observer::monitorSubjectModificationState </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets if a subject's modification state must be monitored. </p>
<dl class="section return"><dt>Returns:</dt><dd>True when the modification state of the object is monitored. False otherwise, or when the subject is not attached to this context.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9a35efa0f88de6961e24c276c6d13e40" title="Sets if a subject&#39;s modification state must be monitored.">setMonitorSubjectModificationState()</a></dd></dl>
<p><em>This function was added in Qtilities v1.2.</em> </p>

</div>
</div>
<a class="anchor" id="ae0f3a77740427719bdbf77876bb4411c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::numberOfSubjectsChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a35b36877048980c1e9acdb1a9ad586ef">Observer::SubjectChangeIndication</a>&#160;</td>
          <td class="paramname"><em>change_indication</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QList&lt; QPointer&lt; QObject &gt; &gt;&#160;</td>
          <td class="paramname"><em>objects</em> = <code>QList&lt;&#160;QPointer&lt;&#160;QObject&#160;&gt;&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A signal which is emitted when the number of subjects change in this observer context. </p>
<p>This signal only indicates if the number of subjects in this observer changes. To monitor number of subject changes in the complete tree under the observer, see <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a>.</p>
<p>Thus, for table views this is enough, for tree views use <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">change_indication</td><td>Slots can use this indicator to know what change occurred. </td></tr>
    <tr><td class="paramname">objects</td><td>A list of objects which was added/removed. When the list contains null items, these objects were deleted and the observer picked it up and removed them. When this signal is emitted in <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> this list will be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>Whenever it is needed to emit this signal, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> will first set the modification state of the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a> to true and then emit the signal. </dd>
<dd>
When a processing cycle is active on the observer, this signal will be emitted at the end of the processing cycle in endProcessingCycle only if the number of subjects changed during the processing cycle. See <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a82b6fa8fb4a53da32b7ba47a55f69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QObject* Qtilities::Core::Observer::objectBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const QObject* base of the interface. </p>
<p>This function can be used in const methods, but make sure that you don't modify things that should stay const. An example where this is used is when we want to get a property on an object in a const method. This is a const operation. </p>

<p>Implements <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_object_base.html#a65633c966e0f4553401ebf6509037c4a">Qtilities::Core::Interfaces::IObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a57341193e333022bc56b08823f6b10b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">Qtilities::Core::Observer::ObjectDeletionPolicy</a> Qtilities::Core::Observer::objectDeletionPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the observer's object deletion policy. </p>
<p>Default is DeleteLater.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a67e214fac1968630563da51e0c661148" title="Function to set the observer&#39;s object deletion policy.">setObjectDeletionPolicy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af9d48fd17492d42adce3cb68399e3741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Qtilities::Core::Observer::parentCount </td>
          <td>(</td>
          <td class="paramtype">const QObject *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to get the number of observers observing the specified object. Thus the number of parents of this object. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa15c4b08b05263b3d54b304e92101d28" title="Convenience function to get the a list of parent observers for this object.">parentReferences()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa15c4b08b05263b3d54b304e92101d28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Qtilities::Core::Observer</a> * &gt; Qtilities::Core::Observer::parentReferences </td>
          <td>(</td>
          <td class="paramtype">const QObject *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to get the a list of parent observers for this object. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#af9d48fd17492d42adce3cb68399e3741" title="Convenience function to get the number of observers observing the specified object. Thus the number of parents of this object.">parentCount()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abecf544807a89ac1e4150bb08098b254"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::propertyChangeFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QList&lt; QObject * &gt;&#160;</td>
          <td class="paramname"><em>objects</em> = <code>QList&lt;&#160;QObject&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A signal which is emitted as soon as an property change event is filtered. </p>
<p>This signal can be emitted in two scenarios:</p>
<ul>
<li>When an attempt is made to modify a reserved property it will always be emitted.</li>
<li>When a monitored property change is not allowed. An example of this is when a name change is rejected.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">property_name</td><td>The name of the property on which the change was filtered. </td></tr>
    <tr><td class="paramname">objects</td><td>The objects on which the property was attempted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9f5624a60522c9885aca302b5aa1a166" title="This function returns a QStringList with the names of all the reserved properties inside this observe...">reservedProperties()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aab01469a6574cad08f38247f25c174fd" title="This function returns a QStringList with the names of all the properties which are monitored by this ...">monitoredProperties()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa987965179b19d1f655de3690b05acc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::qtilitiesPropertyChangeEventsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if QtilitiesPropertyChangeEvents are enabled. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a87d841260596abf11e47d4e66a35ecc0" title="This function enables/disables delivery of QtilitiesPropertyChangeEvents on objects when property cha...">toggleQtilitiesPropertyChangeEvents()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae0cfe4e31430b26561a3343eac0174c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::refreshViewsData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to refresh the data views showing this observer. </p>
<p>This function will emit the dataChanged(this) signal.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>When true views will be updated even if a processing cycle is currently active on the observer. When false the processing cycle will be respected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a240709fed2b99aba07424d19ec80de0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::refreshViewsLayout </td>
          <td>(</td>
          <td class="paramtype">QList&lt; QPointer&lt; QObject &gt; &gt;&#160;</td>
          <td class="paramname"><em>new_selection</em> = <code>QList&lt;QPointer&lt;QObject&gt;&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to refresh the layout views showing this observer. </p>
<p>This function will emit the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a> signal with the new_selection parameter.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>When true views will be updated even if a processing cycle is currently active on the observer. When false the processing cycle will be respected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b689899ede9f68e4c1938a4e198f0ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QPointer&lt; QObject &gt; &gt; Qtilities::Core::Observer::renameCategory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;&#160;</td>
          <td class="paramname"><em>old_category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a> &amp;&#160;</td>
          <td class="paramname"><em>new_category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>match_exactly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames <code>old_category</code> to <code>new_category</code> in this observer context. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_category</td><td>The category to rename. </td></tr>
    <tr><td class="paramname">new_category</td><td>The new name that must be given to the category. </td></tr>
    <tr><td class="paramname">match_exactly</td><td>When true, the old_category must match the new category exactly (thus the depths must match as well). When false, all categories that start with or match the old_category will be updated to start with or match the new category. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A list with the subjects for which the category was renamed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5624a60522c9885aca302b5aa1a166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Qtilities::Core::Observer::reservedProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a QStringList with the names of all the reserved properties inside this observer context. </p>
<p>Reserved properties are internal properties that cannot be changed. The observer will filter any attempted changes to these properties. To check if a property is reserved, see the <code>Permission</code> attribute in the property documentation. All Qtilities properties are defined in the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html" title="Namespace containing reserved observer properties used inside the Core Module.">Qtilities::Core::Properties</a> namespace.</p>
<dl class="section note"><dt>Note:</dt><dd>The list of reserved properties includes reserved properties of any installed subject filters.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abecf544807a89ac1e4150bb08098b254" title="A signal which is emitted as soon as an property change event is filtered.">propertyChangeFiltered()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f358e1fd5410c64067c687691947ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setAccessMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374">AccessMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>&#160;</td>
          <td class="paramname"><em>category</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">QtilitiesCategory</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the observer's access mode. Set the access mode after construction. When subclassing <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, set it in your constructor. </p>
<dl class="section note"><dt>Note:</dt><dd>It is only possible to set the access mode for a category that exist. Thus an object must exist in the observer with the category you want to set the access mode for. </dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Only used when <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b9134f8702c6b25ea62d6bc75efac89" title="Function to return the access mode scope of the observer.">accessModeScope()</a> is categorized. Categories which does not have an access mode set for them will use the global access mode. The global access mode can be set by passing QString() as category. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8013687ec1e85183a4df1ba5423f7bba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setApplicationExportVersion </td>
          <td>(</td>
          <td class="paramtype">quint32&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the application export version currently used by all your application's classes. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a2c374dc64d5d8d47c5ed259f1d1cac41" title="Returns the application export version currently used by all your application&#39;s classes.">applicationExportVersion()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a37d26261d35a8f7f7702f6f4437e576d">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2431a878d6baeb23be5560eb2cdc77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setExportTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_task.html">ITask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the task which must be used to log import/export information to. </p>
<p>To remove the task, use <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab26c935b46c6d708cb8e41cdf9c2b2da" title="Clears the export task.">clearExportTask()</a></p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#af16b7fe85350bdf566709b3cf8e9fcb7" title="Gets the task which must be used to log import/export information to.">exportTask()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ab26c935b46c6d708cb8e41cdf9c2b2da" title="Clears the export task.">clearExportTask()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#ae64df5fbe38c4a6d3a6e90f92ca9cea9">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="a5a29cc3472e868277313987bb65070fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setExportVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_qtilities.html#a46a5ca954966c57c74662ac6e6d8aa25">Qtilities::ExportVersion</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the export version currently used by all Qtilities classes. </p>
<p>By default the latest Qtilities version is selected.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a5d2012183839898b0a9dd97a3d2d55c7" title="Returns the export version currently used by all Qtilities classes.">exportVersion()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a172fa4a4a00c3b58b3d355f1d4438250">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="ac30b68d15d67ac9a8a0b581aabd508c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setFactoryData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_instance_factory_info.html">InstanceFactoryInfo</a>&#160;</td>
          <td class="paramname"><em>factory_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory data which is necessary to reconstruct this observer. </p>
<p>When sub classing from <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>, it might be necessary to set use different factory data settings from the default data used for a normal observer. Call this function in your subclass constructor to change your object's factory data. </p>

</div>
</div>
<a class="anchor" id="af7bbc58f173505a686c7b9acbd9989c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setModificationState </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IModificationNotifier::NotificationTargets&#160;</td>
          <td class="paramname"><em>notification_targets</em> = <code><a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html#ad72709e0da71bdace37c372765c5c556acaf1eec374195b1a1551a858161d90e1">IModificationNotifier::NotifyListeners</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_notifications</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For observers, the listeners will only be notified if a processing cycle is not active or if it is forced using <code>force_notifications</code>.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6" title="Indicates if a processing cycle is active.">isProcessingCycleActive()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a35efa0f88de6961e24c276c6d13e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Observer::setMonitorSubjectModificationState </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets if a subject's modification state must be monitored. </p>
<dl class="section return"><dt>Returns:</dt><dd>True when the needed property was set succesfully on the subject. False otherwise, or when the subject is not attached to this context.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2aa5b3be769ae0b5a6b0acef59070fe3" title="Gets if a subject&#39;s modification state must be monitored.">monitorSubjectModificationState()</a></dd></dl>
<p><em>This function was added in Qtilities v1.2.</em> </p>

</div>
</div>
<a class="anchor" id="a6087d7dcaeee42400eba23dff07f7f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::setMultiContextPropertyValue </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which will set the value of a <a class="el" href="class_qtilities_1_1_core_1_1_multi_context_property.html" title="A MultiContextProperty provides a property which has different values in different contexts...">MultiContextProperty</a> based dynamic property, and not the observer property itself. </p>
<p>If the property_name does not refer to a shared property, the observer context of the observer on which this function is called will be used to define the observer context for which this function will set the property's value. If the <code>property_name</code> refers to a shared property, the shared property's value will be returned. </p>

</div>
</div>
<a class="anchor" id="a67e214fac1968630563da51e0c661148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::setObjectDeletionPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac10bd670cc699870807b5b684461ba8b">ObjectDeletionPolicy</a>&#160;</td>
          <td class="paramname"><em>object_deletion_policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the observer's object deletion policy. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a57341193e333022bc56b08823f6b10b1" title="Function to get the observer&#39;s object deletion policy.">objectDeletionPolicy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab62500e85371cbdf18b9ea2e1f88299c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::setSubjectLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subject_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the subject limit of this observer. </p>
<dl class="section return"><dt>Returns:</dt><dd>Returns true if the limit was set successfully, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a831844b0810e443776f8a2cf0b5e4d01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::startProcessingCycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a processing cycle. </p>
<p>When adding/removing many subjects to the observer it makes sense to only let item views know that the observer changed when all subjects have been added/removed. This function will disable the change notification signals of this observer until <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> is called.</p>
<p>Note that this function only affects signals emitted by the observer. The observer still monitors dynamic property changes on all attached subjects during a processing cycle. To control the event filtering, see <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a> and <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>.</p>
<p>If a processing cycle was already started, this function does nothing.</p>
<p>Internally observers keep track of how many times you start and end processing cycles. To stop a processing cycle you need to call <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> the same number of times you called <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">startProcessingCycle()</a>. Thus, you don't need to keep track if a processing cycle was already started in the beginning of your function (you don't have to care about it). For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_qtilities_1_1_core_1_1_observer.html#ae6955727eee22e2ecaf236c7aa8a321f" title="Default constructor.">Observer</a> obs;</div>
<div class="line">obs.startProcessingCycle(); <span class="comment">// Internal count = 1;</span></div>
<div class="line">obs.startProcessingCycle(); <span class="comment">// Internal count = 2;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Some function gets the observer without any knowledge of previous start/end processing cycle calls:</span></div>
<div class="line"><span class="comment">// It is not necessary to do the following:</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> is_cycle_active = obs.isProcessingCycleActive();</div>
<div class="line">    obs.startProcessingCycle(); <span class="comment">// Internal count = 3;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do some batch processing.</span></div>
<div class="line">    <span class="comment">// If we did not have an internal counter the correct way to end it in a function would be:</span></div>
<div class="line">    <span class="keywordflow">if</span> (!is_cycle_active)</div>
<div class="line">        obs.endProcessingCycle(); <span class="comment">// Internal count = 2;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// However, since there is an internal counter we can ignore the is_cycle_active declaration in the above code and just call:</span></div>
<div class="line">    obs.endProcessingCycle();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">obs.endProcessingCycle(); <span class="comment">// Internal count = 1;</span></div>
<div class="line">obs.endProcessingCycle(); <span class="comment">// Internal count = 0;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note:</dt><dd>It is very important to note that the observer's <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a2881fecc87616d51f2e222f94b522458" title="A signal which is emitted when the layout of the observer or the tree underneath it changes...">layoutChanged()</a> and <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#afa00359a136283610161bf2d82a7114e" title="A signal which is emitted when the data in the observer or the tree underneath it changes...">dataChanged()</a> signals are not emitted during processing cycles. Thus, views displaying the observer are not going to update during processing cycles. When calling endProcessingCycle with the <code>broadcast</code> parameter set to true (the default) the correct signals will be emitted only if the number of subjects changed during the processing cycle. See <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a> for more information.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6" title="Indicates if a processing cycle is active.">isProcessingCycleActive()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9c0d5acccdf0b823df31574d5d37dab9" title="Signal which is emitted when this observer enters a processing cycle.">processingCycleStarted()</a>, startTreeProcessingCyle() </dd></dl>

<p>Reimplemented in <a class="el" href="class_qtilities_1_1_core_gui_1_1_tree_node.html#a41f57b66d538a7418518eec1dab54488">Qtilities::CoreGui::TreeNode</a>.</p>

</div>
</div>
<a class="anchor" id="acee4989f8b736a0d5971178d49f2bc43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::startTreeProcessingCycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a processing cycle. </p>
<p>Same behaviour as startProcessingCyle(), but starts a processing cycle on the complete tree underneath the observer. Thus, processing cycles are started on all observers attached to this observer and those attached to that observer etc. It is important to node that you should use <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abc3ba640a0dd9be561c6e0ea25cb5f40" title="Starts a processing cycle.">endTreeProcessingCycle()</a> when using this function.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abc3ba640a0dd9be561c6e0ea25cb5f40" title="Starts a processing cycle.">endTreeProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">endProcessingCycle()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a883e9ac9aba9b523fab8d6c72b762bc6" title="Indicates if a processing cycle is active.">isProcessingCycleActive()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9c0d5acccdf0b823df31574d5d37dab9" title="Signal which is emitted when this observer enters a processing cycle.">processingCycleStarted()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_qtilities_1_1_core_gui_1_1_tree_node.html#a39f4792dab03841d379d110bd8baacec">Qtilities::CoreGui::TreeNode</a>.</p>

</div>
</div>
<a class="anchor" id="a7939ae4cb248ee5affddd62765e75b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_category.html">Qtilities::Core::QtilitiesCategory</a> &gt; Qtilities::Core::Observer::subjectCategories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a QStringList with all the categories found in the qti_prop_CATEGORY_MAP properties of all attached subjects. </p>
<p>This function does not take the category filtering options of the observer into account, for that functionality see displayedCategories() on the observer hints for this observer provided by hints(). Category filtering is only related to the displaying of the observer. </p>

</div>
</div>
<a class="anchor" id="aabf6283727ab569ea25ba59f110270d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Qtilities::Core::Observer::subjectCount </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>base_class_name</em> = <code>QString()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of subjects currently observed by the observer. </p>
<p>This function is different from <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aba45614f222c4b6d990ad1a156946efa" title="Function to get the number of children under the specified observer.">treeCount()</a> which gets all the children underneath an observer (Thus, children of children etc.). </p>

</div>
</div>
<a class="anchor" id="a4e476df6f4948f33aa0ee0149a975c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Qtilities::Core::Observer::subjectDisplayedNameInContext </td>
          <td>(</td>
          <td class="paramtype">const QObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_displayed_name_property</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validate_object</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the displayed name used for the specified object in this context. QString() is returned if the object is not valid or not attached to this observer. </p>
<p>The displayed name is found using the following sequence, returning the first match:</p>
<ul>
<li>Check if the object has the qti_prop_DISPLAYED_ALIAS_MAP property</li>
<li>Check if the object has the qti_prop_ALIAS_MAP property</li>
<li>Lastly, just return the objectName()</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object for which the name must be fetched. </td></tr>
    <tr><td class="paramname">check_displayed_name_property</td><td>Indicates if the qti_prop_DISPLAYED_ALIAS_MAP property must be checked. </td></tr>
    <tr><td class="paramname">validate_object</td><td>When true, the function will first check if the object exists in the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The name if the object was found, and empty QString() otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7daa3cf44ede8ce0ce6a20ac2ff5be1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::subjectEventFilteringEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if subject event filtering is enabled. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa987965179b19d1f655de3690b05acc1" title="Indicates if QtilitiesPropertyChangeEvents are enabled.">qtilitiesPropertyChangeEventsEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78893642f36421cb651bedf78008d642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Qtilities::Core::Observer::subjectID </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>subject_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::CaseSensitivity&#160;</td>
          <td class="paramname"><em>cs</em> = <code>Qt::CaseSensitive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID associated with a specific subject. </p>
<dl class="section note"><dt>Note:</dt><dd>Only depend on this function (where you specify the object using the object's name) when you are sure that objects have unique names. This can be achieved by installing a NamingPolicyFilter in your observer. If names are not unique, the first match of the given subject_name will be used. If you don't care about unique subject names, rather use subjectReference(int ID) to get subject references. </dd></dl>

</div>
</div>
<a class="anchor" id="ae78402171e9b9862d64ea94785edf1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QPointer&lt; <a class="el" href="class_qtilities_1_1_core_1_1_observer.html">Observer</a> &gt; &gt; Observer::subjectObserverReferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of observers under this observer. </p>
<p>This is an optimized function to get observer references under this observer. Thus, its much faster than something like subjectReferences("Observer") or subjectReferences("TreeNode"). </p>

</div>
</div>
<a class="anchor" id="a3b375085b25e4e41ba859030f28342d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e">Qtilities::Core::Observer::ObjectOwnership</a> Qtilities::Core::Observer::subjectOwnershipInContext </td>
          <td>(</td>
          <td class="paramtype">const QObject *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ownership used for the specified object in this context. </p>
<p>If <code>obj</code> is not valid or contained in this context, ManualOwnership is returned. Thus you should check if the object exists in this context using <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a16903f8e2ff2ef3efdc93218a8efd3f2" title="Returns true if a given subject is currently observed by the observer.">contains()</a> before calling this function. </p>

</div>
</div>
<a class="anchor" id="a4bd2f7ddbc9ad3d82c67c00bb53fc318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QObject * Qtilities::Core::Observer::subjectReference </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>subject_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::CaseSensitivity&#160;</td>
          <td class="paramname"><em>cs</em> = <code>Qt::CaseSensitive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the subject reference for a specific object name. </p>
<dl class="section note"><dt>Note:</dt><dd>Only depend on this function (where you specify the object using the object's name) when you are sure that objects have unique names. This can be achieved by installing a NamingPolicyFilter in your observer. If names are not unique, the first match of the given subject_name will be used. If you don't care about unique subject names, rather use subjectReference(int ID) to get subject references. </dd></dl>

</div>
</div>
<a class="anchor" id="a752b9be37aff4df68ef3afb808d96d42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Qtilities::Core::Interfaces::IExportable::ExportModeFlags Qtilities::Core::Observer::supportedFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides information about the export format(s) supported by your implementation of IExportable. </p>
<dl class="section note"><dt>Note:</dt><dd>It is important to note that you need to check the <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a5d2012183839898b0a9dd97a3d2d55c7" title="Returns the export version currently used by all Qtilities classes.">exportVersion()</a> when you return the supported formats. </dd></dl>

<p>Reimplemented from <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html#a1fe23cf52b3595e58cf76295b7c41086">Qtilities::Core::Interfaces::IExportable</a>.</p>

</div>
</div>
<a class="anchor" id="aa2668fd3c211a83ed33134fb865cda5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::toggleBroadcastModificationStateChanges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toggle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables broadcasting of modification state changes <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Observer</a>. </p>
<p>If you don't use modification state changes turning this off will increase performance.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a89aedbcefb1784ae36ff601e7160099a" title="Indicates if broadcasting of modification state changes are enabled.">broadcastModificationStateChangesEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87d841260596abf11e47d4e66a35ecc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::toggleQtilitiesPropertyChangeEvents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toggle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables delivery of QtilitiesPropertyChangeEvents on objects when property changes occurs. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">toggle</td><td>When true, change events are delivered. When false they are not delivered.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaeef96b6b380c12667adb82c48f7cdc2" title="A signal which is emitted as soon as a monitored property of the observer or any of the installed sub...">monitoredPropertyChanged()</a> for more details on when property change events can be used. If your implementation does not use property change events, you should disabled the events to optimize performance.</p>
<dl class="section note"><dt>Note:</dt><dd>These events are disabled by default.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa987965179b19d1f655de3690b05acc1" title="Indicates if QtilitiesPropertyChangeEvents are enabled.">qtilitiesPropertyChangeEventsEnabled()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#acb1ccbf1beede3d16541ddf100981b41" title="This function toggles event filtering on objects.">toggleSubjectEventFiltering()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acb1ccbf1beede3d16541ddf100981b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Qtilities::Core::Observer::toggleSubjectEventFiltering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toggle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function toggles event filtering on objects. </p>
<p>It is recommended to always keep event filtering enabled. However in some cases, like object reconstruction in ObjectManager::constructRelationships() it is necessary to manually edit read only properties (like ownership etc.). Another example is when you want to attach objects in threads other than the observer's thread to it. In such cases you can disable subject event filtering on objects attached to your subjects.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">toggle</td><td>True is event filtering is enabled, thus property changes are monitored by the observer. False otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>Event filtering is enabled by default. It is also important to know that events won't be monitored on subjects which were attached while subject event filtering was disabled, even if you turn on subject event filtering again at a later stage. Therefore it is best to call this function only once, before attaching any objects to your observer.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7daa3cf44ede8ce0ce6a20ac2ff5be1a" title="Indicates if subject event filtering is enabled.">subjectEventFilteringEnabled()</a>, <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aa987965179b19d1f655de3690b05acc1" title="Indicates if QtilitiesPropertyChangeEvents are enabled.">qtilitiesPropertyChangeEventsEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5163a7a6ec3ce95190fe23fb75c183c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QObject * Qtilities::Core::Observer::treeAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get a QObject reference at a specific location in the tree underneath this observer. </p>
<p>If <code>i</code> is &lt; 0 or bigger than or equal to the number of items retuned by allChildren() this function returns 0. </p>

</div>
</div>
<a class="anchor" id="ae7e206eda0fec302f2c5a8560ddefdc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; QObject * &gt; Qtilities::Core::Observer::treeChildren </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>base_class_name</em> = <code>&quot;QObject&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterator_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the QObject references of all items in the tree underneath this observer. </p>
<p>Returns a list of QObjects* in tree underneath this observer where the list is populated in the same order in which <a class="el" href="class_qtilities_1_1_core_1_1_tree_iterator.html" title="An iterator which iterates through an Observer tree (thus also Qtilities::CoreGui::TreeNode).">Qtilities::Core::TreeIterator</a> iterates through the tree.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_class_name</td><td>The name of the base class of children you are looking for. By default, all children underneath this observer is returned. </td></tr>
    <tr><td class="paramname">limit</td><td>When defined, the tree children will be search up until the limit count is reached. This allows you to stop when a tree gets too big. By default all children are returned. </td></tr>
    <tr><td class="paramname">iterator_id</td><td>Internal iterator ID. You should never use this directly.</td></tr>
  </table>
  </dd>
</dl>
<p>For example:</p>
<div class="fragment"><div class="line">QList&lt;QObject*&gt; children;</div>
<div class="line">TreeNode* rootNode = <span class="keyword">new</span> TreeNode(<span class="stringliteral">&quot;Root&quot;</span>);</div>
<div class="line">TreeNode* parentNode1 = rootNode-&gt;addNode(<span class="stringliteral">&quot;Parent 1&quot;</span>);</div>
<div class="line">TreeNode* parentNode2 = rootNode-&gt;addNode(<span class="stringliteral">&quot;Parent 2&quot;</span>);</div>
<div class="line"></div>
<div class="line">parentNode1-&gt;addItem(<span class="stringliteral">&quot;Child 1&quot;</span>);</div>
<div class="line">parentNode1-&gt;addItem(<span class="stringliteral">&quot;Child 2&quot;</span>);</div>
<div class="line">parentNode2-&gt;addItem(<span class="stringliteral">&quot;Child 3&quot;</span>);</div>
<div class="line">parentNode2-&gt;addItem(<span class="stringliteral">&quot;Child 5&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// The following call will return</span></div>
<div class="line">QList&lt;QObject*&gt; nodes_verify = rootNode-&gt;treeChildren(<span class="stringliteral">&quot;Qtilities::CoreGui::TreeNode&quot;</span>);</div>
<div class="line">QVERIFY(nodes_verify.count() == 2);</div>
<div class="line">QList&lt;QObject*&gt; items_verify = rootNode-&gt;treeChildren(<span class="stringliteral">&quot;Qtilities::CoreGui::TreeItem&quot;</span>);</div>
<div class="line">QVERIFY(items_verify.count() == 5);</div>
</div><!-- fragment --><dl class="section note"><dt>Note:</dt><dd>This observer itself is not part of the list. </dd></dl>

</div>
</div>
<a class="anchor" id="aba45614f222c4b6d990ad1a156946efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Qtilities::Core::Observer::treeCount </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>base_class_name</em> = <code>QString()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the number of children under the specified observer. </p>
<p>This count includes the children of children as well. To get the number of subjects only in this context use <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aabf6283727ab569ea25ba59f110270d2" title="Returns the number of subjects currently observed by the observer.">subjectCount()</a>. </p>
<dl class="section note"><dt>Note:</dt><dd>This observer itself is not counted. </dd></dl>

</div>
</div>
<a class="anchor" id="a7951f5470f8fd0f48dca72bf3e162bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Qtilities::Core::Observer::uninstallSubjectFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html">AbstractSubjectFilter</a> *&#160;</td>
          <td class="paramname"><em>subject_filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstalls a subject filter. </p>
<p>This function will delete the subject filter since subject filters can only be used once at present. </p>

</div>
</div>
<a class="anchor" id="ae61374a82580a82b344f599dec661fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html">Qtilities::Core::ObserverHints</a> * Qtilities::Core::Observer::useDisplayHints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which constructs hints for this observer. </p>
<p>If the observer does not have any hints, this function will construct an <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">ObserverHints</a> instance and assign it to this observer. If the observer already has hints associated with it, this function does nothing.</p>
<dl class="section return"><dt>Returns:</dt><dd>The constructed hints instance, if hints were already present, returns 0.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a417048c7a59f6b87bf580743dc34b06d" title="Function which returns a pointer to the ObserverHints used by this observer.">displayHints()</a>, setDisplayHints() </dd></dl>

</div>
</div>
</div><!-- contents -->
<br><table style="table-layout:auto;	margin: auto; 	border-width:0px 0px 0px 0px; 	border-color:#7F7F7F; 	width:99%;	border-style:solid" CELLPADDING=5 RULES=ROWS FRAME=HSIDES><tr><td style="align: left;width:45%"><a href="http://github.com/JPNaude/Qtilities" title="Qtilities Repository">Qtilities</a> : <a href="index.html" title="Go back to index">Reference Documentation</a></td><td style="align: center;width:10%"><a href="#top" title="Back to top">Back to top</a> </td><td style="text-align: right;width:45%">Copyright &copy; 2009-2013, Jaco Naude</tr></table><br><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-17785825-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script>
