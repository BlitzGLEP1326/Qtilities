/**
\page page_action_management Action Management

<table CELLPADDING=0 style="width:100%;
  table-layout:fixed;
	margin:0px 0px 0px 0px;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;">
<tr> 

<td style="width:80%; padding:0px 5px 0px 0px; vertical-align: text-top; text-align: left">
<h1 style="margin:0px; padding:0px">Overview</h1>

%Qtilities provides classes to allow action management in a Qt application. In small applications it is easy to do action management manually but as applications get bigger, its useful an it saves time to use a proper action management system. The action manager allows actions to be linked with contexts and to change their behavior depending on which context(s) is active. An command editor widget is provided to allow users to change their application wide shortcut settings, or to export or import previous sessions. Lastly, a clipboard manager is provided allowing management of the application clipboard.

This article will explore these features and show how to include the functionality in your application.

Table of contents:
- \ref context_manager
- \ref action_manager
	- \ref menus_and_menubars
	- \ref actions_and_shortcuts
	.
- \ref example_application
- \ref clipboard_manager

</td>

<td style="width:20%; vertical-align: top; margin:0px 0px 0px 0px;">
<table style="table-layout:auto;
	margin:0px 0px 0px 0px; 
  width: 100%;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;
  background-color: #d1d3d4;">
<tr>
<td style="background-color: #5a5c5e; text-align: center">
<h2 style ="color:#FFFFFF">First Steps</h2>
</td>
</tr>
<tr>
<td>
- <a href="page_getting_started.html">Getting Started</a><br>
- <a href="page_the_basics.html">The Basics</a><br>
- <a href="page_examples_and_plugins.html">Examples and Plugins</a><br>
</td>
</tr>
<tr>
<td style="background-color: #5a5c5e; text-align: center">
<h2 style ="color:#FFFFFF">Overviews</h2>
</td>
</tr>
<tr>
<td>
- <a href="page_action_management.html">Action Management</a><br>
- <a href="page_debugging.html">Debugging Applications</a><br>
- <a href="page_extension_system.html">Extension System</a><br>
- <a href="page_factories.html">Factories</a><br>
- <a href="page_logging.html">Logging</a><br>
- <a href="page_modules_overview.html">Modules</a><br>
- <a href="page_object_management.html">Object Management</a><br>
- <a href="page_observers.html">Observers</a><br>
- <a href="page_observer_widgets.html">Observer Widgets</a><br>
- <a href="page_project_management.html">Project Management</a><br>
- <a href="page_tree_structures.html">Building Trees</a><br>
- <a href="page_widget_set.html">Widget Set</a><br>
</td>
</tr>
</table>
</td>

</tr>
</table>

\section context_manager The Context Manager

The context manager is part of the Qtilities::Core module and can be accessed using the CONTEXT_MANAGER macro definition which returns a pointer to the context manager. The context manager implements the Qtilities::Core::Interfaces::IContextManager interface through which developers can communicate with it.

Contexts are represented using a QString value which is assigned to an unique ID as soon as the context is registered in the context manager. It is possible to access and control a context through either its name or id. At any given time 1 or more contexts can be active and contexts can be appended to the current set of active contexts using the Qtilities::Core::Interfaces::IContextManager::appendContext() functions. When the active contexts must be replaced by a new context the Qtilities::Core::Interfaces::IContextManager::setNewContext() function can be called, or when one of the active contexts must be removed Qtilities::Core::Interfaces::IContextManager::removeContext() can be called. %Qtilities provides the Qtilities::Core::Constants::qti_def_CONTEXT_STANDARD context which is always active. Thus if it is needed to use a context which will always be active, the standard context must be used.

%Qtilities provides the Qtilities::Core::Interfaces::IContext interface which objects can implement to indicate that they represent an context. When objects representing this interface are registered in the global object pool their context will automatically be added to the context manager. Contexts can also be registered manually through the Qtilities::Core::Interfaces::IContextManager interface and the current contexts can be obtained and set through this interface.  A range of signals are provided which give notifications about context changes and the Qtilities::Core::Interfaces::IContextManager::broadcastState() function can be used to emit the current state of the context manager at any given time. 

\section action_manager The Action Manager 

%Qtilities provides an action manager class which is responsible to manage actions in Qt applications. The architecture of the action manager was inspired by the action management architecture used in Qt Creator since it is in very well done and powerful in my opinion.

The action manager is part of the Qtilities::CoreGui module and can be accessed using the ACTION_MANAGER macro definition which returns a pointer to the action manager. The action manager implements the Qtilities::CoreGui::Interfaces::IActionManager interface through which developers can communicate with it.

The action manager is used to manage action related items in applications using the %Qtilities libraries. These items includes:
- Menus
- Menu Bars
- Actions
- Shortcuts

All items are referenced using a string ID through the action manager interface.

\subsection menus_and_menubars Menus and menu bars

Managed menus and menu bars implements the Qtilities::CoreGui::ActionContainer base class and access functions for these items will return an action container reference. Menus can be accessed using the Qtilities::CoreGui::ActionContainer::menu() function and menu bars through the Qtilities::CoreGui::ActionContainer::menuBar() function. For menus the menu bar function will return 0, and for menu bars the menu function will return 0.

\subsection actions_and_shortcuts Actions and shortcuts

Actions and shortcuts implement the Qtilities::CoreGui::Command base class and access functions for these items will return a command reference. Actions can be accessed using the Qtilities::CoreGui::Command::action() function and shortcuts through the Qtilities::CoreGui::Command::shortcut() function. For shortcuts the action function will return 0, and for actions the shortcut function will return 0.

Actions and shortcuts are linked to contexts, thus they react differently when different contexts are active. This is a common requirement in big applications where one action must react differently depending on what state the application is in. All actions have a string id and an user text id associated with them. The string id is used internally and is also used to list items in the Qtilities::CoreGui::CommandEditor widget and the user text id is the text which is displayed on the action itself. Note that the string id must also be used when accessing actions through the action manager interface. 

The Qtilities::CoreGui::MultiContextAction class represents an action which has a front-end action which is triggered when the shortcut of the multi context action is used, and any number of back-end actions which each represent a different context. When context changes happen in the application, the multi context action will make the correct back-end action for the set of active contexts active. Thus, when the front-end action trigger, the active back-end action will also trigger. 

The Qtilities::CoreGui::Actions namespace contains a set of ready to use actions and action containers. These constants define the string ids for common menu items and by using these constants, it is easy to place new actions before or after other actions when adding actions to menus (See Qtilities::CoreGui::ActionContainer::addAction() and Qtilities::CoreGui::ActionContainer::addSeperator()).

Actions can be registered in the action manager in three ways:
- An action place holder can be registered which does not have any action back-ends or contexts associated with it. Action/Contexts pairs can then be added to the place holder at a later time as back-end actions..This option is useful when you want to define the layout/structure of your menus in your main function. This is useful in cases where the core menu layout/structure is defined and plugins can then add actions or action back-ends and context to the core menu layout/structure. The Qtilities::CoreGui::Interfaces::IActionManager::registerActionPlaceHolder() function provides this functionality.
- The second option is to register actions directly using Qtilities::CoreGui::Interfaces::IActionManager::registerAction() in which an action and context combination is registered together. This approach creates the action placeholder described in the previous approach automatically.
- For cases where you do not want to manage your back-end action manually and you know that you will only have one back-end action, you can create a multi context action which manages its own single back-end action. This is useful for actions such as File->Exit which is always going to be active and therefore uses the standard context. To create such an action, you can pass the contexts in which the back-end action must be active as the last argument in Qtilities::CoreGui::Interfaces::IActionManager::registerActionPlaceHolder(). This will return a Command class and you can access the back-end action created for you using the action() function on the command. In the example below, the qti_action_FILE_EXIT and qti_action_FILE_SETTINGS actions are examples of this approach.

\subsection example_application Example application: Creating action placeholders in your main() function

The following example shows how the Object Management example in the QtilitiesExamples project defines a core menu layout/structure in the applications' main function. In the example plugins will add action back-ends and context to some of these menu items at a later time when they are loaded. This example uses the ready to use constants in the Qtilities::CoreGui::Actions namespace for the command and action container string ids. The Qtilities::ApplicationGui::QtilitiesMainWindow is also used as the main window in this example and we set the menu bar as the menu bar of this main window.

\code
#include <QtGui>
#include <QtilitiesCoreGui>
using namespace QtilitiesCoreGui;

int main(int argc, char *argv[])
{
    QtilitiesApplication a(argc, argv);
	
    // We must specify the following if we want the logger to remember its settings
    QtilitiesApplication::setOrganizationName("Jaco Naude");
    QtilitiesApplication::setOrganizationDomain("Qtilities");
    QtilitiesApplication::setApplicationName("Object Management Example");
    QtilitiesApplication::setApplicationVersion("0.1");
    
    // Very important: The action manager needs QtilitiesApplication::mainWindow() for the front-end actions of multi context actions
    // It must be done before we initialize the logger since the initialization might construct widget logger front-ends which will attempt to register actions
    QtilitiesMainWindow* exampleMainWindow = new QtilitiesMainWindow();
    QtilitiesApplication::setMainWindow(exampleMainWindow);    

    // Initialize the logger
    LOG_INITIALIZE();
    Log->setIsQtMessageHandler(false);	
	
    // Create menus
    bool existed;
    ActionContainer* menu_bar = ACTION_MANAGER->createMenuBar(qti_action_MENUBAR_STANDARD,existed);
    exampleMainWindow->setMenuBar(menu_bar->menuBar());	
    ActionContainer* file_menu = ACTION_MANAGER->createMenu(qti_action_FILE,existed);
    ActionContainer* edit_menu = ACTION_MANAGER->createMenu(qti_action_EDIT,existed);
    menu_bar->addMenu(file_menu);
    menu_bar->addMenu(edit_menu);	
	
    // Register action place holders for this application. This allows control of your menu structure:
    // File Menu
    QList<int> std_context;
    std_context.push_front(CONTEXT_MANAGER->contextID(qti_def_CONTEXT_STANDARD));
    Command* command = ACTION_MANAGER->registerActionPlaceHolder(qti_action_FILE_SETTINGS,QObject::tr("Settings"),QKeySequence(),std_context);
    // Create the configuration widget here and then connect it to the above command
    ConfigurationWidget config_widget;
    QObject::connect(command->action(),SIGNAL(triggered()),&config_widget,SLOT(show()));
    file_menu->addAction(command);
    file_menu->addSeperator();
    command = ACTION_MANAGER->registerActionPlaceHolder(qti_action_FILE_EXIT,QObject::tr("Exit"),QKeySequence(QKeySequence::Close),std_context);
    QObject::connect(command->action(),SIGNAL(triggered()),QCoreApplication::instance(),SLOT(quit()));
    file_menu->addAction(command);

    // Edit Menu
    command = ACTION_MANAGER->registerActionPlaceHolder(qti_action_EDIT_COPY,QObject::tr("Copy"),QKeySequence(QKeySequence::Copy));
    edit_menu->addAction(command);
    command = ACTION_MANAGER->registerActionPlaceHolder(qti_action_EDIT_CUT,QObject::tr("Cut"),QKeySequence(QKeySequence::Cut));
    edit_menu->addAction(command);
    command = ACTION_MANAGER->registerActionPlaceHolder(qti_action_EDIT_PASTE,QObject::tr("Paste"),QKeySequence(QKeySequence::Paste));
    edit_menu->addAction(command);	
	
    // Register command editor config page:
    OBJECT_MANAGER->registerObject(ACTION_MANAGER->commandEditor());	
	
    // Load the previous session's keyboard mapping file:
    QString shortcut_mapping_file = QString("%1/%2").arg(QtilitiesApplication::applicationSessionPath()).arg(qti_def_PATH_SHORTCUTS_FILE);
    if (ACTION_MANAGER->loadShortcutMapping(shortcut_mapping_file))
        LOG_INFO(QObject::tr("Successfully loaded shortcut mapping from previous session. Path: ") + shortcut_mapping_file);
    else
        LOG_WARNING(QObject::tr("Failed to loaded shortcut mapping from previous session. The default mapping scheme will be used. Path: ") + shortcut_mapping_file);

    // Show the main window:
    exampleMainWindow->show();	
    int result = a.exec();
    
    // Finalize:
    exampleMainWindow->writeSettings();
	
    // Save the current keyboard mapping for the next session:
    if (ACTION_MANAGER->saveShortcutMapping(shortcut_mapping_file))
        LOG_INFO(QObject::tr("Successfully saved shortcut mapping for next session. Path: ") + shortcut_mapping_file);
    else
        LOG_WARNING(QObject::tr("Failed to save shortcut mapping for next session. Path: ") + shortcut_mapping_file);	
	
    LOG_FINALIZE();	
    return result;	
}
\endcode

%Qtilities has the ability to remember shortcut configurations between different application sessions. The Qtilities::CoreGui::Interfaces::IActionManager::loadShortcutMapping() and Qtilities::CoreGui::Interfaces::IActionManager::saveShortcutMapping() functions provide this functionality and the above example shows how to load the shortcut mapping. The example also shows how action manager can save the shortcut mapping for a session when the application exists.

The Qtilities::CoreGui::CommandEditor class provides a shortcuts widget which can be added to your application's configuration widget as shown in the above example. This widgets lists all the registered commands in the action manager where the "Command Name" column refers to the commands' string id and the "Label" column refers to the user text id of actions.

The figure below shows an example of the command editor widget, taken from the object management example.

\image html command_editor.jpg "Command Editor"
\image latex command_editor.eps "Command Editor" width=\textwidth

\section clipboard_manager The Clipboard Manager

The clipboard manager is part of the Qtilities::CoreGui module and can be accessed using CLIPBOARD_MANAGER macro definition which returns a pointer to the context manager. The action manager implements the Qtilities::CoreGui::Interfaces::IClipboard interface through which developers can communicate with it.

The goal of the clipboard manager is to register back-ends (associated with the standard context) for the Qtilities::CoreGui::Actions::qti_action_EDIT_COPY, Qtilities::CoreGui::Actions::qti_action_EDIT_CUT and Qtilities::CoreGui::Actions::qti_action_EDIT_PASTE action placeholders. This is done when the CLIPBOARD_MANAGER->initialize() function is called, allowing control over disabling and enabling these three actions in %Qtilities applications. For example, the paste action should only be enabled if something exists in the the clipboard. Also, when you perform a paste operation, the paste action must become disabled again. The clipboard manager provides this functionality. See the Qtilities::CoreGui::Interfaces::IClipboard class description for more details.

*/
