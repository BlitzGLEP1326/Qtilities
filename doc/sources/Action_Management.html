/**\page page_action_management Managing actions and shortcuts in your applications
\section action_management_overview OverviewQtilities provides classes to allow action management in a Qt application. In small applications it is easy to do action management manually but when applications get bigger it is useful an it saves time to use a proper action management system. The action manager allows actions to be linked with contexts and to change their behavior depending on which context(s) is active. An command editor widget isalso provided to allow users to change their application wide shortcut settings, or to export or import previous sessions. Lastly, a clipboard manager is provided allowing management of the application clipboard.This article will explore these features and show how to include the functionality in your application.Table of contents:- \ref context_manager- \ref action_manager	- \ref menus_and_menubars	- \ref actions_and_shortcuts	.- \ref example_application- \ref context_notifications- \ref clipboard_manager\section context_manager The Context ManagerThe context manager is part of the Qtilities::Core module and can be accessed using the Qtilities::Core::QtilitiesCore::contextManager() function or it can be accessed directly using the CONTEXT_MANAGER macro definition which returns a pointer to the context manager. The context manager implements the Qtilities::Core::Interfaces::IContextManager interface through which developers can communicate with the context manager.Contexts are presented using a QString value which is assigned to an unique ID as soon as the context is registered in the context manager. It is possible to access and control a context through either its name or id. At any given time 1 or more contexts can be active and contexts can be appended to the current set of active contexts using the Qtilities::Core::Interfaces::IContextManager::appendContext() functions. When the active contexts must be replaced by a new context the Qtilities::Core::Interfaces::IContextManager::setNewContext() function can be called, or when one of the active contexts must be removed Qtilities::Core::Interfaces::IContextManager::removeContext() can be called. %Qtilities provides the Qtilities::Core::Constants::CONTEXT_STANDARD context which is always active. Thus if it is needed to use a context which will always be active, the standard context must be used.%Qtilities provides the Qtilities::Core::Interfaces::IContext interface which objects can implement to indicate that they represent an context. When objects representing this interface are registered in the global object pool their context will automatically be added to the context manager. Contexts can also be registered manually through the Qtilities::Core::Interfaces::IContextManager interface and the current contexts can be obtained and set through this interface. \section action_manager The Action Manager %Qtilities provides an action manager class which is responsbile to manage actions in Qt applications. The architecture of the action manager was inspired by the action management architecture used in Qt Creator since it is in very well done and powerful in my opinion.The action manager is part of the Qtilities::CoreGui module and can be accessed using the Qtilities::CoreGui::QtilitiesCore::actionManager() function or it can be accessed directly using the ACTION_MANAGER macro definition which returns a pointer to the context manager. The action manager implements the Qtilities::CoreGui::Interfaces::IActionManager interface through which developers can communicate with the action manager.The action manager is used to manages action related items in applications using the %Qtilities libraries. These items includes:- Menus- Menu Bars- Actions- ShortcutsAll items are referenced using a string id and should be created directly through the action manager interface. \subsection menus_and_menubars Menus and menu barsManaged menus and menubars implements the Qtilities::CoreGui::ActionContainer base class and access functions for these items will return an action container reference. Menus can be acessed using the Qtilities::CoreGui::ActionContainer::menu() function and menu bars through the Qtilities::CoreGui::ActionContainer::menuBar() function.\subsection actions_and_shortcuts Actions and shortcutsActions and shortcuts implements the Qtilities::CoreGui::Command base class and access functions for these items will return a command reference. Actions can be acessed using the Qtilities::CoreGui::Command::action() function and shortcuts through the Qtilities::CoreGui::Command::shortcut() function.Actions and shortcuts are linked to contexts, thus they react differently when different contexts are active. This is a common requirement in big applications where one action must react differently depending on what state the application is in. All actions have a string id and an user text id associated with them. The string id is used internally and is also used to list items in the Qtilities::CoreGui::CommandEditor widget and the user text id is the text which is displayed on the action itself. Note that the string id must also be used when accessing actions through the action manager interface.The Qtilities::CoreGui::Actions namespace contains a set of ready to use actions and action containers. These constants define the string ids for common menu items and by using these constants, it is easy to place new actions before or after other actions when adding actions to menus (See Qtilities::CoreGui::ActionContainer::addAction() and Qtilities::CoreGui::ActionContainer::addSeperator()).Shortcuts can be registered in the action manager usign the Qtilities::CoreGui::Interfaces::IActionManager::registerShortcut() function. Actions can be registered in two ways:- An action place holder can be registered which does not have any action backends or contexts associated with it. Actions and contexts can then be added to the place holder at a later time. This option is usefull when you want to define the layout/structure of your menus in your main function. This is usefull in cases where the core menu layout/structure is defined and plugins can then add actions or action backends and context to the core menu layout/structure. The Qtilities::CoreGui::Interfaces::IActionManager::registerActionPlaceHolder() function provides this functionality.- The second option is to register actions directly using the Qtilities::CoreGui::Interfaces::IActionManager::registerAction() function in which an action and context combination is registered together.\subsection example_application Example applicationThe following example shows how the Object Management example in the QtilitiesExamples project defines a core menu layout/structure in the applications' main function. In the example plugins will add action backends and context to some of these menu items at a later time when they are loaded. This example uses the ready to use constants in the Qtilities::CoreGui::Actions namespace for the command and action container string ids. The Qtilities::ApplicationGui::QtilitiesMainWindow is also used as the main window in this example and we set the menu bar as the menu bar of this main window.\code#include <QtGui>#include <Logger.h>#include <QtilitiesCoreGuiConstants.h>#include <QtilitiesCoreConstants.h>#include <ConfigurationWidget.h>#include <ActionContainer.h>#include <Command.h>#include <QtilitiesMainWindow.h>#include <IConfigPage.h>using namespace Qtilities::CoreGui;using namespace Qtilities::CoreGui::Actions;using namespace Qtilities::ApplicationGui;using namespace Qtilities::Core;using namespace Qtilities::Core::Constants;int main(int argc, char *argv[]){    QApplication a(argc, argv);	    // We must specify the following if we want the logger to remember its settings.    QCoreApplication::setOrganizationName("Jaco Naude");    QCoreApplication::setOrganizationDomain("Qtilities");    QCoreApplication::setApplicationName("Object Management Example");    QCoreApplication::setApplicationVersion("0.1");    // Initialize the logger.    LOG_INITIALIZE(false);    Log->setIsQtMessageHandler(false);		    // Create menus    bool existed;    ActionContainer* menu_bar = ACTION_MANAGER->createMenuBar(MENUBAR_STANDARD,existed);    ActionContainer* file_menu = ACTION_MANAGER->createMenu(MENU_FILE,existed);    ActionContainer* edit_menu = ACTION_MANAGER->createMenu(MENU_EDIT,existed);    menu_bar->addMenu(file_menu);    menu_bar->addMenu(edit_menu);		    // Register action place holders for this application. This allows control of your menu structure.    // File Menu    Command* command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_SAVE,QObject::tr("Save"),QKeySequence(QKeySequence::Save));    file_menu->addAction(command);    file_menu->addSeperator();    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_PRINT,QObject::tr("Print"),QKeySequence(QKeySequence::Print));    file_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_PRINT_PREVIEW,QObject::tr("Print Preview"),QKeySequence());    file_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_PRINT_PDF,QObject::tr("Print PDF"),QKeySequence());    file_menu->addAction(command);    file_menu->addSeperator();    QList<int> std_context;    std_context.push_front(QtilitiesCore::instance()->contextManager()->contextID(CONTEXT_STANDARD));    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_SETTINGS,QObject::tr("Settings"),QKeySequence(),std_context);    // Create the configuration widget here and then connect it to the above command    ConfigurationWidget config_widget;    QObject::connect(command->action(),SIGNAL(triggered()),&config_widget,SLOT(show()));    file_menu->addAction(command);    file_menu->addSeperator();    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_FILE_EXIT,QObject::tr("Exit"),QKeySequence(QKeySequence::Close),std_context);    QObject::connect(command->action(),SIGNAL(triggered()),QCoreApplication::instance(),SLOT(quit()));    file_menu->addAction(command);    // Edit Menu    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_UNDO,QObject::tr("Undo"),QKeySequence(QKeySequence::Undo));    edit_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_REDO,QObject::tr("Redo"),QKeySequence(QKeySequence::Redo));    edit_menu->addAction(command);    edit_menu->addSeperator();    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_COPY,QObject::tr("Copy"),QKeySequence(QKeySequence::Copy));    edit_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_CUT,QObject::tr("Cut"),QKeySequence(QKeySequence::Cut));    edit_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_PASTE,QObject::tr("Paste"),QKeySequence(QKeySequence::Paste));    edit_menu->addAction(command);    edit_menu->addSeperator();    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_SELECT_ALL,QObject::tr("Select All"),QKeySequence(QKeySequence::SelectAll));    edit_menu->addAction(command);    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_CLEAR,QObject::tr("Clear"));    edit_menu->addAction(command);    edit_menu->addSeperator();    command = ACTION_MANAGER->registerActionPlaceHolder(MENU_EDIT_FIND,QObject::tr("Find"),QKeySequence(QKeySequence::Find));    edit_menu->addAction(command);		    // Create a QtilitiesMainWindow    QtilitiesMainWindow exampleMainWindow(0);    QtilitiesCoreGui::instance()->setMainWindow(&exampleMainWindow);    exampleMainWindow.setMenuBar(menu_bar->menuBar());		    // Register command editor config page.    OBJECT_MANAGER->registerObject(ACTION_MANAGER->commandEditor());		    // Load the previous session's keyboard mapping file    QString shortcut_mapping_file = QString("%1/session/%2").arg(QApplication::applicationDirPath()).arg(FILE_SHORTCUT_MAPPING);    if (ACTION_MANAGER->importShortcutMapping(shortcut_mapping_file))        LOG_INFO(QObject::tr("Succesfully loaded shortcut mapping from previous session. Path: ") + shortcut_mapping_file);    else        LOG_WARNING(QObject::tr("Failed to loaded shortcut mapping from previous session. The default mapping scheme will be used. Path: ") + shortcut_mapping_file);    // Show the main window:    exampleMainWindow.show();		    // Important, we let QtilitiesCore know that startup is finished. This results in faster startup times.    QtilitiesCore::instance()->setStartupFinished();    int result = a.exec();    exampleMainWindow.writeSettings();	    // Save the current keyboard mapping for the next session.    if (ACTION_MANAGER->exportShortcutMapping(shortcut_mapping_file))        LOG_INFO(QObject::tr("Succesfully saved shortcut mapping for next session. Path: ") + shortcut_mapping_file);    else        LOG_WARNING(QObject::tr("Failed to save shortcut mapping for next session. Path: ") + shortcut_mapping_file);		    LOG_FINALIZE();	    return result;	}\endcode%Qtilities has the ability to remember shortcut configurations between different applicaton sessions. The Qtilities::CoreGui::Interfaces::IActionManager::importShortcutMapping() and Qtilities::CoreGui::Interfaces::IActionManager::exportShortcutMapping() functions provides this functionality and the above example shows how to load the shortcut mapping. The action manager will automatically save the shortcut mapping for a session when the application exists.The Qtilities::CoreGui::CommandEditor class provides a shortcut configuration widget which can be added to your application configuration widget as shown in the above example. This widgets lists all the registered commands in the action manager where the "Command Name" column referrs to the commands' string id and the "Label" column referrs to the user text id of actions.The figure below shows and example of the command editor widget, taken from the object management example.\image html command_editor.jpg "Command Editor"\image latex command_editor.eps "Command Editor" width=\textwidth\section context_notifications Context change notificationsThe context manager provides a range of signals which give notifications about context changes. The Qtilities::Core::Interfaces::IContextManager::broadcastState() function can be used to emit the current state of the context manager at any given time. Because all actions registered in the action manager have one or more contexts associated with them, context changes can become expensive operations since all actions must be updated for the new context. For this reason the context manager checks the Qtilities::Core::QtilitiesCore::startupFinished() function before emitting any signals, thus during application startup no action context updates will happen which will increase startup times.\section clipboard_manager The Clipboard ManagerThe clipboard manager is part of the Qtilities::CoreGui module and can be accessed using the Qtilities::CoreGui::QtilitiesCore::clipboardManager() function or it can be accessed directly using the CLIPBOARD_MANAGER macro definition which returns a pointer to the context manager. The action manager implements the Qtilities::CoreGui::Interfaces::IClipboardManager interface through which developers can communicate with the clipboard manager.The goal of the clipboard manager is to register backends (associated with the standard context) for the Qtilities::CoreGui::Actions::MENU_EDIT_COPY, Qtilities::CoreGui::Actions::MENU_EDIT_CUT and Qtilities::CoreGui::Actions::MENU_EDIT_PASTE action placeholders if they exists. This allows control over disabling and enabling these three actions in %Qtilities applications. For example, the paste action should only be enabled if something exists in the the clipboard. Also, when you perform a paste operation, the paste action must become disabled again. The clipboard manager provides this functionality.See the clipboard manager interface class description for more details.*/