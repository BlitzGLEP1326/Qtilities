/**
\page page_extension_system Extension System

<table CELLPADDING=0 style="width:100%;
  table-layout:fixed;
	margin:0px 0px 0px 0px;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;">
<tr> 

<td style="width:80%; padding:0px 5px 0px 0px; vertical-align: text-top; text-align: left">
<h1 style="margin:0px; padding:0px">Overview</h1>

%Qtilities provides an extension management library which has the following goals and responsibilities:
- Define how plugins interface with an application.
- Getting the plugins up and running. This includes plugin loading, initialization and finalization.
- Provide management of plugin configuration sets, that is: Provide control over which plugins must be loaded and initialized.
- Provide information about the loaded plugins once they are loaded and initialized.

The Qtilities::ExtensionSystem::ExtensionSystemCore singleton provides the interface through which these tasks can be achieved.  This article will provide details of how the extension system achieves these goals and give an overview of the different features provided.

Table of contents:
- \ref define_plugins
- \ref define_lifetime_management
  - \ref loading_plugins
  - \ref init_and_finalization_sequence
  .
- \ref plugin_information
- \ref plugin_config_sets

</td>

<td style="width:20%; vertical-align: top; margin:0px 0px 0px 0px;">
<table style="table-layout:auto;
	margin:0px 0px 0px 0px; 
  width: 100%;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;
  background-color: #d1d3d4;">
<tr>
<td style="background-color: #5a5c5e; text-align: center">
<h2 style ="color:#FFFFFF">First Steps</h2>
</td>
</tr>
<tr>
<td>
- <a href="page_getting_started.html">Getting Started</a><br>
- <a href="page_the_basics.html">The Basics</a><br>
- <a href="page_examples_and_plugins.html">Examples and Plugins</a><br>
</td>
</tr>
<tr>
<td style="background-color: #5a5c5e; text-align: center">
<h2 style ="color:#FFFFFF">Overviews</h2>
</td>
</tr>
<tr>
<td>
- <a href="page_action_management.html">Action Management</a><br>
- <a href="page_extension_system.html">Extension System</a><br>
- <a href="page_factories.html">Factories</a><br>
- <a href="page_logging.html">Logging</a><br>
- <a href="page_modules_overview.html">Modules</a><br>
- <a href="page_object_management.html">Object Management</a><br>
- <a href="page_observers.html">Observers</a><br>
- <a href="page_observer_widgets.html">Observer Widgets</a><br>
- <a href="page_project_management.html">Project Management</a><br>
- <a href="page_tree_structures.html">Building Trees</a><br>
- <a href="page_widget_set.html">Widget Set</a><br>
</td>
</tr>
</table>
</td>

</tr>
</table>

\section define_plugins Goal 1: Define how plugins interface with an application

The Qtilities::ExtensionSystem::Interfaces::IPlugin interface defines the interface between the extension system and plugins it can load. The interface provides status information about the state of a plugin as well as information about the plugin itself and was made as lightweight as possible. Therefore it does not inherit from anything and any object can implement it.

Lets look at a simplified version of the \p PluginTemplate example in the \p QtilitiesPlugins project which is a ready to use template implementing this interface. First lets look at the header %file:
\code
class PluginTemplate : public QObject, public IPlugin
{
    Q_OBJECT
    Q_INTERFACES(Qtilities::ExtensionSystem::Interfaces::IPlugin)

public:
    PluginTemplate(QObject* parent = 0);
    ~PluginTemplate() {}

    // --------------------------------
    // IObjectBase Implementation
    // --------------------------------
    QObject* objectBase() { return this; }
    const QObject* objectBase() const { return this; }

    // --------------------------------------------
    // IPlugin Implementation
    // --------------------------------------------
    bool initialize(const QStringList &arguments, QString *errorString);
    bool initializeDependancies(QString *errorString);
    void finalize() {}
    QString pluginName() const { return "Example Plugin"; }
    QtilitiesCategory pluginCategory() const { return QtilitiesCategory("General"); }
    double pluginVersion() const { return 1; }
    QStringList pluginCompatibilityVersions() const;
    QString pluginPublisher() const;
    QString pluginPublisherWebsite() const;
    QString pluginPublisherContact() const;
    QString pluginDescription() const;
    QString pluginCopyright() const;
    QString pluginLicense() const;
};
\endcode

And next we look at the \p .cpp implementation %file:
\code
PluginTemplate::PluginTemplate(QObject* parent) : QObject(parent) {
    setObjectName(pluginName());
}

bool PluginTemplate::initialize(const QStringList &arguments, QString *errorString) {
    Q_UNUSED(arguments)
    Q_UNUSED(errorString)

    return true;
}

bool PluginTemplate::initializeDependancies(QString *errorString) {
    Q_UNUSED(errorString)

    return true;
}

QStringList PluginTemplate::pluginCompatibilityVersions() const {
    // Returning an empty QStringList() indicates that the plugin can be used in any application, thus
    // it is not dependent on the application it is used. Examples are the Session Log and Project
    // Management plugins that comes with %Qtilities.
    return QStringList();
}

QString PluginTemplate::pluginPublisher() const {
    return "Jaco Naude";
}

QString PluginTemplate::pluginPublisherWebsite() const {
    return "http://www.qtilities.org";
}

QString PluginTemplate::pluginPublisherContact() const {
    return "support@qtilities.org";
}

QString PluginTemplate::pluginDescription() const {
    return tr("An example Qtilities Extension System plugin.");
}

QString PluginTemplate::pluginCopyright() const {
    return QString(tr("Copyright") + " 2010, Jaco Naude");
}

QString PluginTemplate::pluginLicense() const {
    return tr("See the Qtilities Libraries license");
}

Q_EXPORT_PLUGIN2(PluginTemplate, PluginTemplate);
\endcode

The implementation above shows that it is very easy to implement the interface and the best place to start is to use Qtilities::Plugins::Template.

\section define_lifetime_management Goal 2: Getting the plugins up and running

\subsection loading_plugins Loading plugins

The Qtilities::ExtensionSystem::ExtensionSystemCore::initialize() function loads plugins from path(s) defined in Qtilities::ExtensionSystem::ExtensionSystemCore::pluginPaths(). By default all plugins in the \p EXECUTABLE_PATH/plugin directory are loaded and new paths can be added using the Qtilities::ExtensionSystem::ExtensionSystemCore::addPluginPath() function.

During the loading process, the extension system core class emits the \p newProcessMessage() signal with progress messages which can be connected to a splash window if necessary (see the Qtilities::Examples::MainWindow example which demonstrates this for more information). 

The example below shows how to use the extension system to load plugins in your application's main() function.

\code
#include <QtGui>
#include <QtilitiesExtensionSystem>
using namespace QtilitiesCore;
using namespace QtilitiesCoreGui;
using namespace QtilitiesExtensionSystem;

int main(int argc, char *argv[])
{
  QtilitiesApplication a(argc, argv);

  // We must specify the following if we want the logger to remember its settings:
  QtilitiesApplication::setOrganizationName("Jaco Naude");
  QtilitiesApplication::setOrganizationDomain("Qtilities");
  QtilitiesApplication::setApplicationName("Extension System Example");
  QtilitiesApplication::setApplicationVersion("0.1");	 

  // Initialize the logger:
  LOG_INITIALIZE();

  // Set the Qt message engine active, this will log messages to the Qt debugging system during the plugin loading process:
  Log->toggleQtMsgEngine(true);
  // Load plugins using the extension system:
  EXTENSION_SYSTEM->initialize();
  // Set the Qt message engine inactive once the process loading process is completed:
  Log->toggleQtMsgEngine(false);

  // Register extension system config page:
  OBJECT_MANAGER->registerObject(ExtensionSystemCore::instance()->configWidget());

  // Report on the number of config pages found:
  QList<QObject*> registered_config_pages = OBJECT_MANAGER->registeredInterfaces("IConfigPage");
  LOG_INFO(QString("%1 configuration page(s) found in set of loaded plugins.").arg(registered_config_pages.count()));

  // Create a config widget for this example:
  ConfigurationWidget config_widget;
  config_widget.initialize(registered_config_pages);
  
  exampleMainWindow->show();
  int result = a.exec();
  
  // Finalize all plugins:
  ExtensionSystemCore::instance()->finalize();
  // Finalize the logger:
  LOG_FINALIZE();
  
  return result;
}

\endcode

The above example registers the Qtilities::ExtensionSystem::ExtensionSystemConfig widget in the global object pool which is discussed in the \ref plugin_information section.

\subsection init_and_finalization_sequence Plugin initialization and finalization

The diagram below shows the sequence in which plugins are initialized during the plugin loading process.

\image html plugin_loading_sequence.jpg "Plugin Loading Sequence"
\image latex plugin_loading_sequence.eps "Plugin Loading Sequence" width=\textwidth

Plugins should register any objects in which other plugins or the main application might be interested in (configuration pages, contexts) etc. in the Qtilities::ExtensionSystem::Interfaces::IPlugin::initialize() function implementation. After all plugin instances were created and added to the global object pool, this function is called on all plugins. That is, all plugins are loaded first before any of them are initialized. To make things clear, lets look at simplified version of the \p initialize() function implementation in the Qtilities::Plugins::SessionLog plugin:

\code
bool Qtilities::Plugins::SessionLog::SessionLogPlugin::initialize(const QStringList &arguments, QString *errorString) {
    Q_UNUSED(arguments)
    Q_UNUSED(errorString)

    // Add the session log mode to the global object pool:
    SessionLogMode* session_log_mode = new SessionLogMode();
    OBJECT_MANAGER->registerObject(session_log_mode);

    // Register the context of the session log mode:
    CONTEXT_MANAGER->registerContext(session_log_mode->contextString());

    // Register the logging configuration widget:
    OBJECT_MANAGER->registerObject(LoggerGui::createLoggerConfigWidget(false));

    return true;
}
\endcode

This is followed by calling the Qtilities::ExtensionSystem::Interfaces::IPlugin::initializeDependancies() function on all plugins. In this function plugins can inspect the global object pool to for interfaces they are interested in using the Qtilities::Core::Interfaces::IObjectManager::registeredInterfaces() function. Again, to make things clear lets write an implementation of the \p initializeDependencies() function which looks for all projects parts registered in the global object pool:

\code
bool ProjectPartFinderPlugin::initializeDependancies(QString *errorString) {
    Q_UNUSED(errorString)

    // Get a list of all the project items in the object pool:
    QList<QObject*> projectItemObjects = OBJECT_MANAGER->registeredInterfaces("IProjectItem");
    QList<IProjectItem*> projectItems;

    // Cast all items:
    for (int i = 0; i < projectItemObjects.count(); i++) {
        IProjectItem* part = qobject_cast<IProjectItem*> (projectItemObjects.at(i));
        if (part)
          projectItems.append(part);
    }
    
    // Now we will have a list with all the project items in the global object pool.
    return true;
}
\endcode

\section plugin_config_sets Goal 3: Provide management of plugin configuration sets

In advanced applications it is often desirable to specify a set of plugins which should be loaded for different scenarios. In %Qtilities we call a set of plugins that must be loaded for a specific scenario a plugin configuration set. The extension system allow management of different configuration sets and before explaining this in more detail, lets define three things that can happen to a valid plugin found in any of the plugin paths specified:
- <b>Active Plugins:</b> Plugins which are loaded an initialized.
- <b>Inactive Plugins:</b> Plugins which are loaded but not initialized. This is needed in order for the plugin to still be shown in the plugin details widget and to allow user control over creation of configuration sets.
- <b>Filtered Plugins:</b> Plugins which are filtered/skipped, thus not loaded or initialized. This is usefull in scenarios where the same application is deployed to different places and only specific plugins should be exposed to users when they create plugin configuration sets.

A configuration set gives the names of the plugins which falls into each of the three categories above. When a plugin is found during the Qtilities::ExtensionSystem::ExtensionSystemCore::initialize() function call, the plugin is checked agains the information provided by the configuration set and handled accordingly. When a plugin is found which is not categorized in the configuration set, it automatically falls under the Active Plugins category. In the same way, if a plugin occurs under more than one category in the configuration set, it automatically falls under the Active Plugins set.

\section plugin_information Goal 4: Provide plugin information at runtime

The main access point to information about loaded plugins is the extension system configuration widget class (Qtilities::ExtensionSystem::ExtensionSystemConfig). The configuration widget is shown below:

\image html extension_system_configuration_widget.jpg "Extension System Widget Plugin Overview"

The "Plugin Paths" tab in the configuration widget provides details about the paths searched for plugins, thus it shows the paths returned by Qtilities::ExtensionSystem::ExtensionSystemCore::pluginPaths(). For each plugin we can get detailed information by double clicking its name, or by clicking the "Details" button. The image below shows the detailed information of one of the provided %Qtilities plugins.

\image html extension_system_details_widget.jpg "Plugin Details"
 
*/
