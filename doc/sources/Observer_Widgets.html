/**\page page_observer_widgets Observer Widgets: Displaying the contents of an observer context
\section observer_widgets_overview Overview%Qtilities provides a power implementation of the subject-observer pattern and an easy way to display the contents of such an observer context. The main class with which observers are viewed is Qtilities::CoreGui::ObserverWidget. The observer widget is able to show the contents as a tree widget or as a table widget and the user can specify the view which is required as a parameter of the constructor. Observers provide hints to item views displaying their contents which specify how the context must be shown, what actions can be performed on the items in the context and what the access mode of the observer is etc. %Qtilities also provides the Qtilities::CoreGui::ObjectScopeWidget which provides a widget with details of an object's scope.This article will show how to use the observer widget class and how it is linked with the observer context it is displaying and an overview of the object scope widget will also be given. Note that the ObserverWidgetExample example in the QtilitiesExamples project contains the code used in this example.Table of contents:- \ref first_steps_observer_widgets	- \ref table_view	- \ref selected_object_integration	.- \ref observer_and_widget_integration	- \ref action_hints	- \ref selection_control	- \ref item_view_display	- \ref controlling_names	- \ref hierarchical_display	- \ref controlling_activity	- \ref controlling_displayed_columns	- \ref access_mode	- \ref observer_widget_searching	.- \ref scope_widget- \ref advanced_topics	- \ref widget_meta_types	- \ref saving_state	- \ref models_overview	.\section first_steps_observer_widgets First steps: Creating your first observer widgetTo create an observer widget is very simple, first we need an observer context and then we can initialize the observer widget for that observer context. We will use the same tree structure that was introduced in the \ref page_tree_structures article in here. Now lets look at an example where we construct that tree structure and create an observer widget for it.\code#include <QApplication>#include <QtilitiesCoreGui>using namespace QtilitiesCore;using namespace QtilitiesCoreGui;int main(int argc, char *argv[]){  QtilitiesApplication a(argc, argv);  // Create the observers  Observer* observerA = new Observer("Observer A","Observer A");  Observer* observerB = new Observer("Observer B","Observer B");  Observer* observerC = new Observer("Observer C","Observer C");  // Create the objects  QObject* object1 = new QObject();  object1->setObjectName("Object 1");  QObject* object2 = new QObject();  object2->setObjectName("Object 2");  QObject* object3 = new QObject();  object3->setObjectName("Object 3");  QObject* object4 = new QObject();  object4->setObjectName("Object 4");  QObject* object5 = new QObject();  object5->setObjectName("Object 5");  // Create the structure of the tree  observerA->attachSubject(observerB);  observerA->attachSubject(observerC);  observerA->attachSubject(object1);  observerA->attachSubject(object4);  observerB->attachSubject(object2);  observerB->attachSubject(object3);  observerC->attachSubject(object5);  observerC->attachSubject(object3);  // Create the observer widget, set its context and then initialize it  ObserverWidget* observer_widget = new ObserverWidget();  observer_widget->setObserverContext(observerA);  observer_widget->initialize();  observer_widget->show();  return a.exec();}\endcodeWhen the above application is run, the following widget is shown:\image html observer_widget_tree.jpg "Observer Widget (Tree View Mode)"\image latex observer_widget_tree.eps "Observer Widget (Tree View Mode)" width=3in\subsection table_view Constructing the observer widget as a table viewObserver widgets are by default initialized as tree widgets. However we can decide we want a table view rather than a tree view by passing the correct parameter in the observer constructor as shown below. \codeObserverWidget* observer_widget = new ObserverWidget(ObserverWidget::TableView);\endcodeThe resulting widget looks like this:\image html observer_widget_table.jpg "Observer Widget (Table View Mode)"\image latex observer_widget_table.eps "Observer Widget (Table View Mode)" width=3inFor flat observer structures the above widget would be sufficient, however for hierarchical tree structures such as the example structure we are using, this is not going to work. The user must be able to push down into an observer and push up the tree as well. In order to do this, we need to add actions for to the observer widget which the user can then use to perform these tasks. The following changes is needed in the above example:\code// We need to tell all three observers that they should provide hints for the actions we want to observer widgets displaying them. Observer hints are described in details later in this article.ObserverHints::ActionHints action_hints = 0;action_hints |= ObserverHints::PushDown;action_hints |= ObserverHints::PushUp;action_hints |= ObserverHints::SwitchView;observerA->useDisplayHints();observerA->displayHints()->setActionHints(action_hints);observerB->useDisplayHints();observerB->displayHints()->setActionHints(action_hints);observerC->useDisplayHints();observerC->displayHints()->setActionHints(action_hints);// For our example we add all actions provided by the observer widget to a toolbar at the top of the observer widget.QList<QAction*> actions = observer_widget->actionProvider()->actions();QToolBar* toolbar = observer_widget->addToolBar("Context Toolbar");observer_widget->addToolBar(toolbar);toolbar->addActions(actions);\endcodeThese additions will result in the observer widget shown below:\image html observer_widget_table_with_actions.jpg "Observer Widget With Action Toolbar"\image latex observer_widget_table_with_actions.eps "Observer Widget With Action Toolbar" width=3inA third action, specified by Qtilities::Core::Observer::SwitchView was also added to our example. When this action is present the user can switch the type of view when needed. Lastly, observer widgets automatically provides actions to expand or collapse tree structures when the observer widget is in the tree mode. In the above widget they are not shown since the observer widget is in table mode.\subsection selected_object_integration Interacting with selected objectsThe observer widget class provides functions which makes it easy to interact with selected objects in the item view presented to the user. It is possible to retrieve selected objects at any time using the Qtilities::CoreGui::ObserverWidget::selectedObjects() function. The selectedObjectsChanged() signal is emitted when the active objects changes and the observerContextChanged() signal is emitted as soon as the observer context in the widget change. This would happen for example when the user push down into a tree hierarchy.\section observer_and_widget_integration Observer hints: Telling item views how they should show an observer contextObservers can provide display hints any observer widgets in which it is displayed. The available hints are defined in the form of the Qtilities::Core::ObserverHints class and are explained in this section. Observer widgets automatically follow the hints of the widget's current observer context if the context provides hints. It is however possible to turn this feature off using the Qtilities::CoreGui::ObserverWidget::toggleUseObserverHints() function and then set the hints explicitly using the Qtilities::CoreGui::ObserverWidget::inheritObserverHints() function. Observers does not automatically provide hints and the Qtilities::Core::Observer::useDisplayHints() function must be called on the an observer after it is constructed and before any subjects are attached to it.The hints are interpreted when the observer widget is initialized, thus they must be set before the initialization function call on the observer widget.\subsection action_hints Overview of different action hintsAction hints are hints which tells observer widgets which actions must be available for a specific context. The observer widget class implements the Qtilities::CoreGui::Interfaces::IActionProvider interface through which it provides all the actions for a specific observer context. Actions are created as needed during initialization calls on the observer widget, thus if an observer context does not provide any action hints, no actions will be created and the interface will provide an empty list of actions.The previous section already showed how to use the action provider interface and how to enable action hints for an observer. The possible action hints are defined in the Qtilities::Core::ObserverHints::ActionHint enumeration.\subsection selection_control Control over object selectionIf is possible to control if objects displayed underneath a specific context can be selected in the observer widget. For more information see Qtilities::Core::ObserverHints::setItemSelectionControlHint() and Qtilities::Core::ObserverHints::itemSelectionControlHint().\subsection item_view_display Control over which widgets appears in the observer widgetIn the examples thus far we only showed an item view and for table views an navigation bar at the top of the widget in the observer widget. It is possible to control this through the Qtilities::Core::ObserverHints::setDisplayFlagsHint() and Qtilities::Core::ObserverHints::displayFlagsHint() functions. Lets modify our example to also display an Qtilities::CoreGui::ObjectPropertyBrowser in the observer widget through which users can edit Q_PROPERTY properties of the selected object.\code// We need to tell all three observers that they should provide hints for the actions we want to observer widgets displaying them. Observer hints are described in details later in this article.ObserverHints::DisplayFlags display_flags = 0;display_flags |= ObserverHints::ItemView;display_flags |= ObserverHints::NavigationBar;display_flags |= ObserverHints::PropertyBrowser;observerA->displayHints()->setDisplayFlagsHint(display_flags);observerB->displayHints()->setDisplayFlagsHint(display_flags);observerC->displayHints()->setDisplayFlagsHint(display_flags);// Before the observer widget initialization we can specify where the editor should be, and of what type the editor must be:observer_widget->setPreferredPropertyEditorDockArea(Qt::RightDockWidgetArea);observer_widget->setPreferredPropertyEditorType(ObjectPropertyBrowser::TreeBrowser);// After the observer widget was initialized we can access the property editor and call functions on it:if (observer_widget->propertyBrowser()) {	QStringList filter_list;	filter_list << "QObject";	observer_widget->propertyBrowser()->setFilterList(filter_list);}\endcodeThese additions will result in the observer widget shown below:\image html observer_widget_with_property_browser.jpg "Observer Widget With Property Browser"\image latex observer_widget_with_property_browser.eps "Observer Widget With Property Browser" width=4in\subsection controlling_names Controlling namesThe Qtilities::Core::Observer::setNamingControlHint() function can be called to provide a hint which will determine if object names should be editable or not. The Qtilities::CoreGui::NamingPolicyFilter was created to help with name management inside an observer context and when an observer context with a naming policy filter installed is set as the observer context of an observer widget, the naming policy filter will automatically be used to help with name management by providing a Qtilities::CoreGui::NamingPolicyDelegate delegate which is used during the editing of object names. Lets adapt our example by installing a naming policy filter set to use unique names to our top level observer, and we set the naming control hint on the observer to editable names. \code// Create and install a naming policy filter:NamingPolicyFilter* naming_filter = new NamingPolicyFilter();naming_filter->setUniquenessPolicy(NamingPolicyFilter::ProhibitDuplicateNames);observerA->installSubjectFilter(naming_filter);// We also need to call setNamingControlHint() on our observer:observerA->displayHints()->setNamingControlHint(ObserverHints::EditableNames);\endcodeThe image below shows what happens when we want to change an object name inside the top level observer context to the name of an existing object.\image html observer_widget_naming_delegate.jpg "Observer Widget Handling Context Naming Policies"\image latex observer_widget_naming_delegate.eps "Observer Widget Handling Context Naming Policies" width=4in\subsection hierarchical_display Hierarchical (categorized) display optionsAn useful feature of the Qtilities::Core::Observer class is that it supports the grouping of objects which in the context into categories. The Qtilities::Core::Observer::setHierarchicalDisplayHint() function can be used to enable the categorized display hint on the observer in order for observer widgets to display the objects in the observer's context in their categories.Lets change our example again by adding intended categories for objects that we attach to observerC.\code// We replace the "Create the objects" section with the code below:QObject* object1 = new QObject();object1->setObjectName("Object 1");QObject* object2 = new QObject();object2->setObjectName("Object 2");QObject* object3 = new QObject();ObserverProperty category_property3(OBJECT_CATEGORY);category_property3.setValue("Category 1",observerC->observerID());Observer::setObserverProperty(object3,category_property3);object3->setObjectName("Object 3");QObject* object4 = new QObject();object4->setObjectName("Object 4");QObject* object5 = new QObject();ObserverProperty category_property5(OBJECT_CATEGORY);category_property5.setValue("Category 2",observerC->observerID());Observer::setObserverProperty(object5,category_property5);object5->setObjectName("Object 5");// We also need to call setHierarchicalDisplayHint() on our observer:observerC->displayHints()->setHierarchicalDisplayHint(ObserverHints::CategorizedHierarchy);\endcodeThese changes will result in the observer widget shown below when in tree mode:\image html observer_widget_categories_tree_mode.jpg "Observer Widget With Categories (Tree View Mode)"\image latex observer_widget_categories_tree_mode.eps "Observer Widget With Categories (Tree View Mode)" width=4inIt is also possible to view categories in the table mode by enabling the category column on observerC.\codeobserverC->setItemViewColumnFlags(Observer::CategoryColumn);\endcode\image html observer_widget_categories_table_mode.jpg "Observer Widget With Categories (Table View Mode)"\image latex observer_widget_categories_table_mode.eps "Observer Widget With Categories (Table View Mode)" width=4inIt is also possible to filter the categories which are displayed:\code// We also need to call setHierarchicalDisplayHint() on our observer:QStringList displayed_categories;displayed_categories << "Category 2";observerC->displayHints()->setDisplayedCategories(displayed_categories);observerC->displayHints()->setCategoryFilterEnabled(true);\endcodeAfter adding the category filter, the observer widget will look like this:\image html observer_widget_categories_tree_mode_filtered.jpg "Observer Widget With Filtered Categories (Tree View Mode)"\image latex observer_widget_categories_tree_mode_filtered.eps "Observer Widget With Filtered Categories (Tree View Mode)" width=4in\subsection controlling_activity Controlling activityIn the same way that observer widgets integrate with naming policy filters, automatic integration with activity policy filters also happens when an observer context displayed by an observer widget has a Qtilities::Core::ActivityPolicyFilter installed. Observers provide two hints related to activity control: a hint indicating how activity must be displayed (see Qtilities::Core::Observer::ActivityDisplay) and a hint indicating how activity changes should happen (see Qtilities::Core::Observer::ActivityControl). Lets adapt our example by installing an activity policy filter and experiment with different activity hints. \code// Create and install activity policy filters on observerA and observerB:// Observer A:ActivityPolicyFilter* activity_filter = new ActivityPolicyFilter();activity_filter->setActivityPolicy(ActivityPolicyFilter::MultipleActivity);activity_filter->setMinimumActivityPolicy(ActivityPolicyFilter::AllowNoneActive);observerA->installSubjectFilter(activity_filter);observerA->displayHints()->setActivityControlHint(Observer::CheckboxTriggered);observerA->displayHints()->setActivityDisplayHint(Observer::CheckboxActivityDisplay);// Observer B:activity_filter = new ActivityPolicyFilter();activity_filter->setActivityPolicy(ActivityPolicyFilter::MultipleActivity);activity_filter->setMinimumActivityPolicy(ActivityPolicyFilter::AllowNoneActive);observerB->installSubjectFilter(activity_filter);observerB->displayHints()->setActivityControlHint(Observer::CheckboxTriggered);observerB->displayHints()->setActivityDisplayHint(Observer::CheckboxActivityDisplay);\endcodeAfter adding the activity filter, the observer widget will look like this:\image html observer_widget_checkbox_activity.jpg "Observer Widget Handling Context Activity Policy"\image latex observer_widget_checkbox_activity.eps "Observer Widget Handling Context Activity Policy" width=4inIt is up to the user to reader to explore the other activity display and control alternatives.The Qtilities::Core::ActivityPolicyFilter class also provides other activity management options which allows control over the activity of subjects within an observer context.\subsection controlling_displayed_columns Control over displayed columnsThe Qtilities::Core::ObserverHints::ItemViewColumn hint provides control over pre-defined columns that can be shown in the observer widget. Lets enable all columns and look at the resulting observer widget.\code// We need to set the item view column hint on our observer:observerA->displayHints()->setItemViewColumnFlags(ObserverHints::AllColumnsHint);observerB->displayHints()->setItemViewColumnFlags(ObserverHints::AllColumnsHint);observerC->displayHints()->setItemViewColumnFlags(ObserverHints::AllColumnsHint);\endcodeAfter setting the item view column hint, the observer widget will look like this:\image html observer_widget_column_hints.jpg "Observer Widget With All Columns Enabled"\image latex observer_widget_column_hints.eps "Observer Widget With All Columns Enabled" width=4in\subsection access_mode Access mode and access mode scopeObserver access modes provides the ability to control the changes which can be made to an observer and are defined in the Qtilities::Core::Observer::AccessMode enumeration. Observers provide the ability to specify access modes on a global scope or on a category level through the Qtilities::Core::Observer::setAccessModeScope() function. Again, lets modify our example by setting the access mode of the observers in the example (Note that we do this after the attachments for our example).\code// Set access modes only now after all subjects were attachedobserverB->setAccessMode(Observer::ReadOnlyAccess);observerC->setAccessMode(Observer::LockedAccess);\endcodeThe resulting observer widget is shown below. It must be noted that the AccessColumn item view column must be provided by the observer context:\image html observer_widget_access_mode_tree_mode.jpg "Observer Widget Handling Observer Access Mode (Tree View Mode)"\image latex observer_widget_access_mode_tree_mode.eps "Observer Widget Handling Observer Access Mode (Tree View Mode)" width=4inThe table mode's hierarhcy navigation bar goes a step further and colors the name of a read only context in red as an direct indication that the context is read only.\image html observer_widget_access_mode_table_mode.jpg "Observer Widget Handling Observer Access Mode (Table View Mode)"\image latex observer_widget_access_mode_table_mode.eps "Observer Widget Handling Observer Access Mode (Table View Mode)" width=4in\subsection observer_widget_searching Searching for objects inside the observer widgetObserver widgets can automatically show a search box widget embedded at the bottom of the widget when observers specificy that they support finding options. Lets change your example once more:\code// We need to tell all three observers that they should provide an action hint for the search action as well.ObserverHints::ActionHints action_hints = observerA->actionHints();action_hints |= ObserverHints::FindItem;observerA->displayhints()->setActionHints(action_hints);observerB->displayhints()->setActionHints(action_hints);observerC->displayhints()->setActionHints(action_hints);\endcodeThe resulting widget will display a find action, and when clicked it will provide an integrated Qtilities::CoreGui::SearchBoxWidget to the user.\image html observer_widget_searching.jpg "Observer Widget Search Demonstration"\image latex observer_widget_searching.eps "Observer Widget Search Demonstration" width=4in\section scope_widget Using the Object Scope WidgetAs explained in the \ref page_observers article, an object can be attached to multiple observers. In such cases it be usefull to display the scope of an object within the application using the Qtilities::CoreGui::ObjectScopeWidget. Let's create an observer widget for object 3 in our example since it is attached to both observerB and observerC.\code // Create the object scope widget and set it's object to object3:ObjectScopeWidget* scope_widget = new ObjectScopeWidget();scope_widget->setObject(object3);scope_widget->show();\endcodeThe object scope widget is shown below. Tooltips provide more information about specific context and different columns are available to provide details about each context. In our example, only the "Alias" column is shown indicating that the name used in that context is an aliased name.\image html object_scope_widget_without_owner.jpg "Object Scope Widget Without Owner"\image latex object_scope_widget_without_owner.eps "Object Scope Widget Without Owner" width=3inWe can go a step further and change the line where object 3 is attached to observerB to the following:\codeobserverB->attachSubject(object3,Observer::SpecificObserverOwnership);\endcodeThe object scope widget now provides additional information, showing which context is the owner of the object.\image html object_scope_widget_with_owner.jpg "Object Scope Widget With Owner"\image latex object_scope_widget_with_owner.eps "Object Scope Widget With Owner" width=3in\section advanced_topics Advanced topics\subsection widget_meta_types Setting observer widget meta typesThe %Qtilities object manager is able to manage global active objects, for more information see the \ref page_object_management article. The observer widget class can integrate with the object manager and the meta type which is used for a specific observer widget can be set usign the Qtilities::CoreGui::ObserverWidget::setGlobalMetaType() function.\subsection saving_state Saving the state of different observer widgetsThe ObserverWidget class provides the Qtilities::CoreGui::ObserverWidget::writeSettings() and Qtilities::CoreGui::ObserverWidget::readSettings() function which can be used to store information about an observer widget. The following information is stored:- The mode (tree or table widget)- The main window state (including dock widgets and toolbars)The settings is stored using QSettings under a group called Gui/Widget_Name, with the application settings prepended to this group. This is shown below:\code// This must be set in your application's main() function with your parameters:QtilitiesApplication::setOrganizationName("Jaco Naude");QtilitiesApplication::setOrganizationDomain("Qtilities");QtilitiesApplication::setApplicationName("Observer Widget Example");QtilitiesApplication::setApplicationVersion("0.1");// This is the way settings are stored:QSettings settings;settings.beginGroup("GUI");settings.beginGroup(widget_name);// Store detailssettings.endGroup();settings.endGroup();\endcodeThe Widget_Name field in the group where the settings are stored is set the first time you read or write settings and is passed as a parameter to both function. Observer widget classes are connected to the Qtilities::Core::QtilitiesCore::settingsUpdateRequest() signal by default and responds to settings update requests for the specific widget name.\subsection models_overview The models doing the work behind the scenesDepending on the mode in which the observer widget is, it uses data models designed specifically for the observer implementation. In tree mode, the model doing the work is Qtilities::CoreGui::ObserverTreeModel, and in table mode Qtilities::CoreGui::ObserverTableModel is used.*/