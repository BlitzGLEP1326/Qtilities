/**\page page_tree_structures Building and viewing hierarchical tree structures
\section tree_structures_overview Overview%Qtilities provides a set of classes which allows you to easily build and view complex hierarchical tree structures. The QObject implementation in Qt already allows you to build trees since each QObject can have a parent and multiple children. Although this is a very powerful feature of Qt it does have some limitations:- Each QObject can only have one parent.- There is no ready to use data model which can be used to view tree structures.These problems are addressed and many features are added to make working with hierarchical trees in Qt easier for developers.Table of contents:- \ref qtilities_tree_structure- \ref tree_structures_features	- \ref view_trees	- \ref multiple_parents	- \ref monitor_changes	- \ref compare_trees	- \ref trees_export_import	- \ref trees_lifetime_monitoring	- \ref observer_subject_filters	.- \ref tree_parsing\section qtilities_tree_structure The Qtilities Tree StructureBefore we look at the features provided by the %Qtilities implementation, we need to understand how trees are build in %Qtilities. The diagram below shows a standard tree structure on the left, and the corresponding tree structure on the right using %Qtilities blockswhere necessary.\image html tree_structure.jpg "Example Tree Structure"\image latex tree_structure.eps "Example Tree Structure" width=\textwidthThe central and most important class in the tree is the Qtilities::Core::Observer class. This class allows objects to be attached to it where the objects must inherit from QObject. It is also possible to attache other observers to an observer. For an in-depth overview of the observer class, see the following article: \ref page_observersTo build the tree structure shown above is very simple and shown below. Note that object names are used as the string presented in the tree, thus we set the object names of each object before we attach the objects to the observers.\code#include <QApplication>#include <Observer.h>#include <ObserverWidget.h>using namespace Qtilities::Core;using namespace Qtilities::CoreGui;int main(int argc, char *argv[]){    QApplication a(argc, argv);    // Create the observers    Observer* observerA = new Observer("Observer A","Top level observer");    Observer* observerB = new Observer("Observer B","Child observer");    Observer* observerC = new Observer("Observer C","Child observer");    // Create the objects    QObject* object1 = new QObject();    object1->setObjectName("Object 1");    QObject* object2 = new QObject();    object2->setObjectName("Object 2");    QObject* object3 = new QObject();    object3->setObjectName("Object 3");    QObject* object4 = new QObject();    object4->setObjectName("Object 4");    QObject* object5 = new QObject();    object5->setObjectName("Object 5");    // Create the structure of the tree    observerA->attachSubject(observerB);    observerA->attachSubject(observerC);    observerA->attachSubject(object1);    observerA->attachSubject(object4);    observerB->attachSubject(object2);    observerB->attachSubject(object3);    observerC->attachSubject(object5);    observerC->attachSubject(object3);    ObserverWidget* tree_widget = new ObserverWidget(ObserverWidget::TreeView);    tree_widget->setObserverContext(observerA);    tree_widget->initialize();    tree_widget->show();    return a.exec();}\endcodeWe can get the parents or children of any item in the tree as follows:\code// Get the number of parents:// For this tree, parent_count_1 = 1 and parent_count_3 = 2int parent_count_1 = Observer::parentCount(object1);int parent_count_3 = Observer::parentCount(object3);// Get the references of any objects' parentsQList<Observer*> parents_object3 = Observer::parentReferences(object3);// Get the number of childrenint number_children_A = observerA->subjectCount();int number_children_B = observerB->subjectCount();int number_children_C = observerC->subjectCount();// Get the references to all childrenQList<QObject*> children_A = observerA->subjectReferences();\endcodeThe above code samples shows the most basic way of constructing the tree and is available as the BuildingTreeStructures example in the QtilitiesExamples project. It is possible to extend this example quite a bit to add additional functionality and customization to the tree. These extensions will be explained and shown in the features section.\section tree_structures_features FeaturesThis section highlights some of features and advantages of the %Qtilities tree structure.\subsection view_trees Easy to view, no need to create item view modelsProbably the most useful and powerful feature of these trees is that they can be viewed without any effort from the developer's side. For our example, we can show this tree using the following lines of code.\code#include <ObserverWidget.h>using namespace Qtilities::CoreGui;ObserverWidget* tree_widget = new ObserverWidget(ObserverWidget::TreeView);tree_widget->setObserverContext(observerA);tree_widget->initialize();tree_widget->show();\endcodeThe resulting tree widget looks like this:\image html observer_widget_tree.jpg "Tree Structure In Observer Widget"\image latex observer_widget_tree.eps "Tree Structure In Observer Widget" width=3inAlternatively we can show the tree as a table where we can push up and down in the tree hierarchy. It is recommended to read the following articleto get an understanding of how the Qtilities::CoreGui::ObserverWidget class works: \ref page_observer_widgets\subsection multiple_parents Multiple parentsAny object can have multiple parents and can be attached anywhere in the tree multiple times. The tree structure figure shows this where the greyobject is attached multiple times in the tree, but it is the same object. A limitation of this flexibility is that recursive tree structures are not allowed and this is automatically checked each time a new child is attached to an observer. An example of such a recursive tree would be when you attach the root item (top level observer) to one of the other observers. This does not make sense logically and it would not be possible to display such a tree.\subsection monitor_changes Monitor changes to the treeA powerful feature is the ability to monitor modifications to a tree. This is done through the Qtilities::Core::Interfaces::IModificationNotifier interface. This interface allows any object in the tree to broadcast any changes to its modification state. An example of where this is useful is where a tree is part of a project. In that case we want to indicate to the user that the project must be saved as soon as the tree structure or any of the objects in the tree change.We can check if a the example tree is modified, and change the modification state of the tree as follows:\code// Check if the tree is modifiedif (observerA->isModified()){	// If it is modified, we change its modification state to false for this example:	observerA->setModificationState(false,false,true);}\endcode\subsection compare_trees Compare trees with each otherTrees can be compared to each other, and information about a tree can be serialized to a QDataStream using the Qtilities::Core::ObserverRelationalTable class.For example:\code#include <ObserverRelationalTable.h>#include <QDataStream>#include <QTemporaryFile>ObserverRelationalTable tableA(observerA);// Now we can dump detailed information about the tree to the logger.tableA.dumpTableInfo();// We can compare two trees with each other:ObserverRelationalTable tableB(observerB);if (!tableA.compare(tableB)) {	// Tables are different, which will be the case for the example tree.}// We can export detailed information about a table to a QDataStream:QTemporaryFile test_file;test_file.open();QDataStream test_stream_out(&test_file);tableA.exportBinary(test_stream_out);test_file.close();test_file.open();QDataStream test_stream_in(&test_file);    // read the data serialized from the fileObserverRelationalTable readback_table;readback_table.importBinary(test_stream_in);test_file.close();if (tableA.compare(readback_table)) {	// We will always get here since the table was compared to itself}	\endcodeThe exporting and importing of table information is very useful when validating trees after they are imported. For more information about this see theobserver import and exporting features of the Qtilities::Core::ObjectManager class, and the next section.\subsection trees_export_import Exporting and Importing treesTrees can easily be exported and imported. At present only binary importing/exporting is supported. This feature is made possible through the Qtilities::Core::Interfaces::IExportable interface which is implemented by the observer class. When a tree is exported, a recursive search for anyobjects in the tree implementing this interface occurs. Thus, if only QObject 3 in the example tree implement this interface, the export will only contain ObserverA, ObserverB, ObserverC and QObject3. Lets look at an example of how you would export and import a tree:\code#include <QtilitiesCore.h>#include <IObjectManager.h>// Trees are exported like this:QTemporaryFile test_file;test_file.open();QDataStream test_stream_out(&test_file);if (QtilitiesCore::instance()->objectManager()->exportObserverBinary(test_stream_out,observerA) == IExportable::Failed)	// Export failedelse	// Export successful	test_file.close();test_file.open();	// Trees are imported like this:// First delete all objects in the tree.ObserverA->deleteAll();	if (QtilitiesCore::instance()->objectManager()->importObserverBinary(test_stream_out,observerA) == IExportable::Failed)	// Import failedelse	// Import successful	test_file.close();\endcode\subsection trees_lifetime_monitoring Trees automatically monitors the lifetime of objects in the treeTrees automatically monitor the lifetime of objects inside the tree. For example:\code// We delete object 1 as an example:delete object1;// The resulting tree will automatically remove object1 and any views viewing the tree will refresh themselves.// We can also delete all objects in the tree like this:observerA->deleteAll();// If we want to remove all objects from the tree but we don't want to delete them we do this:observerA->detachAll();\endcodeNote that observerB and observerC will still have their objects attached to them after the above call. It is important to avoid memory leaks when detaching objects, thus you must then manually manage the lifetime. See the object lifetime management article for more information on this topic.\subsection observer_subject_filters Using Observer subject filters to customize your treesUsing subject filters you can impose rules on which objects can be attached to which observers etc. See the \ref page_observers article for more information.\section tree_parsing Under the hood: How trees are parsedTrees are parsed in a specific way depending on what you are doing with the tree. This section provides details of how the parsing happens inside the %Qtilities classes. This section will be added in the future.*/