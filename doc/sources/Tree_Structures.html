/**\page page_tree_structures Building Trees<table CELLPADDING=0 style="width:100%;  table-layout:fixed;	margin:0px 0px 0px 0px;	border-width:0px 0px 0px 0px; 	border-color:#7F7F7F;"><tr> <td style="width:80%; padding:0px 5px 0px 0px; vertical-align: text-top; text-align: left"><h1 style="margin:0px; padding:0px">Overview</h1>%Qtilities provides a set of classes which allows you to easily build and view complex hierarchical tree structures. The QObject implementation in Qt already allows you to build trees since each QObject can have a parent and multiple children. Although this is a very powerful feature of Qt it does have some limitations:- Each QObject can only have one parent.- There is no ready to use data model which can be used to view tree structures.These problems are addressed and many features are added to make working with hierarchical trees in Qt easier for developers.Table of contents:- \ref qtilities_tree_structure- \ref tree_structures_features	- \ref view_trees	- \ref multiple_parents	- \ref monitor_changes	- \ref compare_trees	- \ref trees_export_import	- \ref trees_lifetime_monitoring	- \ref observer_subject_filters	.- \ref tree_parsing  - \ref tree_parsing_areas  - \ref tree_parsing_observer_observer  - \ref tree_parsing_observer_object_observer  .</td><td style="width:20%; vertical-align: top; margin:0px 0px 0px 0px;"><table style="table-layout:auto;	margin:0px 0px 0px 0px;   width: 100%;	border-width:0px 0px 0px 0px; 	border-color:#7F7F7F;  background-color: #d1d3d4;"><tr><td style="background-color: #5a5c5e; text-align: center"><h2 style ="color:#FFFFFF">First Steps</h2></td></tr><tr><td>- <a href="page_getting_started.html">Getting Started</a><br>- <a href="page_the_basics.html">The Basics</a><br>- <a href="page_examples_and_plugins.html">Examples and Plugins</a><br></td></tr><tr><td style="background-color: #5a5c5e; text-align: center"><h2 style ="color:#FFFFFF">Overviews</h2></td></tr><tr><td>- <a href="page_action_management.html">Action Management</a><br>- <a href="page_extension_system.html">Extension System</a><br>- <a href="page_factories.html">Factories</a><br>- <a href="page_logging.html">Logging</a><br>- <a href="page_modules_overview.html">Modules</a><br>- <a href="page_object_management.html">Object Management</a><br>- <a href="page_observers.html">Observers</a><br>- <a href="page_observer_widgets.html">Observer Widgets</a><br>- <a href="page_project_management.html">Project Management</a><br>- <a href="page_tree_structures.html">Building Trees</a><br>- <a href="page_widget_set.html">Widget Set</a><br></td></tr></table></td></tr></table>\section qtilities_tree_structure The Qtilities Tree StructureBefore we look at the features provided by the %Qtilities implementation, we need to understand how trees are build in %Qtilities. The diagram below shows a standard tree structure on the left, and the corresponding tree structure on the right using %Qtilities blocks where necessary.\image html tree_structure.jpg "Example Tree Structure"\image latex tree_structure.eps "Example Tree Structure" width=\textwidthThe central and most important class in the tree is the Qtilities::Core::Observer class. This class allows objects to be attached to it where the objects must inherit from QObject. It is also possible to attach other observers to an observer. For an in-depth overview of the observer class, see the \ref page_observers article.To build the tree structure shown above is very simple and shown below. Note that object names are used as the string presented in the tree, thus we set the object names of each object before we attach them to the observers.\code#include <QApplication>#include <QtilitiesCoreGui>using namespace QtilitiesCore;using namespace QtilitiesCoreGui;int main(int argc, char *argv[]){    QtilitiesApplication a(argc, argv);    // Create the observers    Observer* observerA = new Observer("Observer A","Top level observer");    Observer* observerB = new Observer("Observer B","Child observer");    Observer* observerC = new Observer("Observer C","Child observer");    // Create the objects    QObject* object1 = new QObject();    object1->setObjectName("Object 1");    QObject* object2 = new QObject();    object2->setObjectName("Object 2");    QObject* object3 = new QObject();    object3->setObjectName("Object 3");    QObject* object4 = new QObject();    object4->setObjectName("Object 4");    QObject* object5 = new QObject();    object5->setObjectName("Object 5");    // Create the structure of the tree    observerA->attachSubject(observerB);    observerA->attachSubject(observerC);    observerA->attachSubject(object1);    observerA->attachSubject(object4);    observerB->attachSubject(object2);    observerB->attachSubject(object3);    observerC->attachSubject(object5);    observerC->attachSubject(object3);    ObserverWidget* tree_widget = new ObserverWidget(ObserverWidget::TreeView);    tree_widget->setObserverContext(observerA);    tree_widget->initialize();    tree_widget->show();    return a.exec();}\endcodeWe can get the parents or children of any item in the tree as follows:\code// Get the number of parents:// For this tree, parent_count_1 = 1 and parent_count_3 = 2int parent_count_1 = Observer::parentCount(object1);int parent_count_3 = Observer::parentCount(object3);// Get the references of any objects' parentsQList<Observer*> parents_object3 = Observer::parentReferences(object3);// Get the number of childrenint number_children_A = observerA->subjectCount();int number_children_B = observerB->subjectCount();int number_children_C = observerC->subjectCount();// Get the references to all childrenQList<QObject*> children_A = observerA->subjectReferences();\endcodeThe above code samples shows the most basic way of constructing the tree and is available as the BuildingTreeStructures example in the QtilitiesExamples project. For an overview of the different ways that trees can be parsed, see \ref tree_parsing. It is possible to extend the above example quite a bit to add additional functionality and customization to the tree. These extensions will be explained and shown in the features section.\section tree_structures_features FeaturesThis section highlights some of features and advantages of the %Qtilities tree structure.\subsection view_trees Easy to view, no need to create item view modelsProbably the most useful and powerful feature of these trees is that they can be viewed without any effort from the developer's side. For our example, we can show this tree using the following lines of code.\codeObserverWidget* tree_widget = new ObserverWidget(ObserverWidget::TreeView);tree_widget->setObserverContext(observerA);tree_widget->initialize();tree_widget->show();\endcodeThe resulting tree widget looks like this:\image html observer_widget_tree.jpg "Tree Structure In Observer Widget"\image latex observer_widget_tree.eps "Tree Structure In Observer Widget" width=3inAlternatively we can show the tree as a table where we can push up and down in the tree hierarchy. It is recommended to read the following articleto get an understanding of how the Qtilities::CoreGui::ObserverWidget class works: \ref page_observer_widgets\subsection multiple_parents Multiple parentsAny object can have multiple parents and can be attached anywhere in the tree multiple times. The tree structure figure shows this where the greyobject is attached multiple times in the tree, but it is the same object. A limitation of this flexibility is that recursive tree structures are not allowed and this is automatically checked each time a new child is attached to an observer. An example of such a recursive tree would be when you attach the root item (top level observer) to one of the other observers. This does not make sense logically and it would not be possible to display.\subsection monitor_changes Monitor changes to the treeA powerful feature is the ability to monitor modifications to a tree. This is done through the Qtilities::Core::Interfaces::IModificationNotifier interface. This interface allows any object in the tree to broadcast any changes to its modification state. An example of where this is useful is where a tree is part of a project. In that case we want to indicate to the user that the project must be saved as soon as the tree structure or any of the objects in the tree change.We can check if a the example tree is modified, and change the modification state of the tree as follows:\code// Check if the tree is modifiedif (observerA->isModified()){	// If it is modified, we change its modification state to false for this example:	observerA->setModificationState(false,IModificationNotifier::NotifySubjects);}\endcodeObservers also provide a number of signals which can be monitored if you are interested in specific changes in a tree. See the Qtilities::Core::Observer class documentation for more information.\subsection compare_trees Compare trees with each otherTrees can be compared to each other, and information about a tree can be serialized to a QDataStream using the Qtilities::Core::ObserverRelationalTable class.For example:\codeObserverRelationalTable tableA(observerA);// Now we can dump detailed information about the tree to the loggertableA.dumpTableInfo();// We can compare two trees with each other:ObserverRelationalTable tableB(observerB);if (!tableA.compare(tableB)) {	// Tables are different, which will be the case for the example tree}// We can export detailed information about a table to a QDataStreamQTemporaryFile test_file;test_file.open();QDataStream test_stream_out(&test_file);tableA.exportBinary(test_stream_out);test_file.close();test_file.open();QDataStream test_stream_in(&test_file);    // read the data serialized from the fileObserverRelationalTable readback_table;readback_table.importBinary(test_stream_in);test_file.close();if (tableA.compare(readback_table)) {	// We will always get here since the table was compared to itself}	\endcodeThe exporting and importing of table information is very useful when validating trees after they are imported. For more information see the observer import and exporting features of the Qtilities::Core::ObjectManager class or the \ref trees_export_import section of this article.\subsection tree_structures_observer_hints Define how the tree should look by providing hints for the context shownThe observer class provides a concept called observer hints. These hints are called display hints since they guide widgets displaying the context of the observer. The available hints are defined in the Qtilities::Core::ObserverHints class and can be used on any observer by calling the Qtilities::Core::Observer::useDisplayHints() function after the observer was constructed. The \ref page_observer_widgets article explores these different hints and shows what their effects are on the visualized observer context.\subsection trees_export_import Exporting and Importing treesTrees can easily be exported and imported. At present only binary importing/exporting is supported. This feature is made possible through the Qtilities::Core::Interfaces::IExportable interface which is implemented by the observer class. When a tree is exported, a recursive search for any objects in the tree implementing this interface occurs. Thus, if only \p QObject 3 in the example tree implement this interface, the export will only contain \p ObserverA, \p ObserverB, \p ObserverC and \p QObject3. Lets look at an example of how you would export and import a tree:\code// Trees are exported like this:QTemporaryFile test_file;test_file.open();QDataStream test_stream_out(&test_file);if (OBJECT_MANAGER->exportObserverBinary(test_stream_out,observerA) == IExportable::Failed)	// Export failedelse	// Export successful	test_file.close();test_file.open();	// Trees are imported like this:// First delete all objects in the tree.ObserverA->deleteAll();	if (OBJECT_MANAGER->importObserverBinary(test_stream_out,observerA) == IExportable::Failed)	// Import failedelse	// Import successful	test_file.close();\endcode\subsection trees_lifetime_monitoring Trees automatically monitors the lifetime of objects in the treeTrees automatically monitor the lifetime of objects inside the tree. For example:\code// We delete object 1 as an example:delete object1;// The resulting tree will automatically remove object1 and any views viewing the tree will refresh themselves.// We can also delete all objects in the tree like this:observerA->deleteAll();// If we want to remove all objects from the tree but we don't want to delete them we do this:observerA->detachAll();\endcodeNote that \p observerB and \p observerC will still have their objects attached to them after the above call. It is important to avoid memory leaks when detaching objects, thus you must then manually manage the lifetime. See \ref object_lifetimes for more information on this topic.\subsection observer_subject_filters Using Observer subject filters to customize your treesUsing subject filters you can impose rules on which objects can be attached to which observers etc. See the \ref subject_filters section of the \ref page_observers article for more information on subject filters. \section tree_parsing Under the hood: How trees are parsedTrees are parsed in a specific way depending on what you are doing with the tree. This section provides details of how the parsing happens inside the %Qtilities classes. \subsection tree_parsing_areas Tree parsing areasIn %Qtilities trees are parsed in several places and it is important to make sure parsing happens in the same way everywhere. The following list gives an overview of classes where tree parsing happens:- Qtilities::Core::ObserverRelationalTable- Qtilities::Core::Observer- Qtilities::CoreGui::AbstractObserverTreeModel- Qtilities::CoreGui::AbstractObserverTableModel- Qtilities::CoreGui::ObserverWidgetAll of these classes support the following approaches to parsing trees.\subsection tree_parsing_observer_observer Approach 1: Observer with child observersThis approach is the most common and easiest and was used in the examples presented in this article so far. The tree is made up of Observers with other observers underneath it, with other observers underneath these observers etc. \subsection tree_parsing_observer_object_observer Approach 2: Observer containment approachIt is also possible to create trees in a more advanced way. For example:\code// Create a couple of observersObserver* observerA = new Observer("Observer A","Top level observer");Observer* observerB = new Observer("Observer B","Contained observer");// Create the objectsQObject* object1 = new QObject();object1->setObjectName("Object 1");QObject* object2 = new QObject();object2->setObjectName("Object 2");QObject* object3 = new QObject();object3->setObjectName("Object 3");// Attach object2 and object3 to observerBobserverB->attachSubject(object2);observerB->attachSubject(object3);// Set object1 as the parent of observerB:observerB->setParent(object1);\endcodeThe above code would create a tree which looks as follows:\image html tree_structure_containment_approach.jpg "Tree Structure: Containment Approach"This approach allows for creation of complex trees. It solves the problem where you want to attach a class instance with children underneath it to a tree but the class already inherits QObject and since Qtilities::Core::Observer also inherts QObject the class cannot inherit Qtilities::Core::Observer. The limitation of this approach is that only the first observer child of an object is parsed. If we would add another observer child to \p object1 in the example above, it will not be part of the parsed tree.*/