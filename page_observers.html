<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Qtilities: Observers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Observers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table  cellpadding="0" style="width:100%;
  table-layout:fixed;
	margin:0px 0px 0px 0px;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;">
<tr>
<td style="width:80%; padding:0px 5px 0px 0px; vertical-align: text-top; text-align: left"><h1 style="margin:0px; padding:0px">Overview</h1>
<p></p>
<p>The <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Qtilities::Core::Observer</a> class provides a powerful implementation of the subject - observer programming pattern. The observer class is the observer in this implementation (as the name suggests) and any QObject based class can be a subject. One way to think about an observer is to think of it as a context in your application to which certain subjects can be attached or detached. An example of such a context is the observer which manages plugins in the Qtilities extension system. When plugins are loaded they are attached to this context and become visible in the list of loaded plugins. Another example would be different instances of a scripting engine. When new objects are created inside the scripting engine they exist in that context. It can then for example be possible to have multiple scripting engines within the same application, where different objects belongs to different script engines or are shared between the engines using Observers.</p>
<p>The Qtilities implementation of this pattern is a very powerful addition to any Qt programmer's toolbox and this article will explain the many different features of the implementation.</p>
<p>Table of contents:</p>
<ul>
<li><a class="el" href="page_observers.html#observers_introduction">Introduction through simple examples</a><ul>
<li><a class="el" href="page_observers.html#creating_contexts">First steps: Creating an observer contexts and attaching objects to it</a></li>
<li><a class="el" href="page_observers.html#sharing_objects">Object sharing: Attaching an object to multiple contexts</a></li>
<li><a class="el" href="page_observers.html#observer_subject_IDs">Observer &amp; Subject IDs: Accessing objects using unique IDs</a></li>
<li><a class="el" href="page_observers.html#object_categories">Object categories: Organizing objects into categories inside a context</a></li>
<li><a class="el" href="page_observers.html#object_lifetimes">Object lifetimes: Managing object lifetimes using observers</a></li>
</ul>
</li>
<li><a class="el" href="page_observers.html#qtilities_properties">Dynamic properties used and managed by Observers</a><ul>
<li><a class="el" href="page_observers.html#different_properties">Different property types</a></li>
<li><a class="el" href="page_observers.html#important_properties">Important properties and how they are interpreted</a></li>
<li><a class="el" href="page_observers.html#monitoring_property_changes">Monitoring property changes and changing properties</a></li>
</ul>
</li>
<li><a class="el" href="page_observers.html#subject_filters">Subject filters</a><ul>
<li><a class="el" href="page_observers.html#subject_filter_attachment_involvement">Attaching an object to an observer context with subject filters</a></li>
<li><a class="el" href="page_observers.html#context_activity">Managing context activity</a></li>
<li><a class="el" href="page_observers.html#managing_names">Managing names within a context</a></li>
<li><a class="el" href="page_observers.html#managing_object_types">Managing object types within a context</a></li>
<li><a class="el" href="page_observers.html#custom_filters">Creating custom subject filters</a></li>
</ul>
</li>
<li><a class="el" href="page_observers.html#observer_advanced_topics">Advanced topics</a><ul>
<li><a class="el" href="page_observers.html#context_dependency">Context dependency: Creating context aware classes</a></li>
<li><a class="el" href="page_observers.html#observer_hints">Observer hints: Define the way your context must be displayed</a></li>
<li><a class="el" href="page_observers.html#batch_processing">Batch processing: Optimization using processing cycles</a></li>
<li><a class="el" href="page_observers.html#modification_state">Modification state: Check if an observer changed</a></li>
<li><a class="el" href="page_observers.html#exporting_importing">Exporting and importing observers</a></li>
<li><a class="el" href="page_observers.html#building_trees">Using observers to build hierarchical trees</a></li>
<li><a class="el" href="page_observers.html#access_modes">Access modes: Define user access on a per context basis</a></li>
</ul>
</li>
</ul>
<p class="endtd"></p>
</td><td style="width:20%; vertical-align: top; margin:0px 0px 0px 0px;"><table  style="table-layout:auto;
	margin:0px 0px 0px 0px; 
  width: 100%;
	border-width:0px 0px 0px 0px; 
	border-color:#7F7F7F;
  background-color: #d1d3d4;">
<tr>
<td style="background-color: #5a5c5e; text-align: center"><h2 style="color:#FFFFFF">First Steps</h2>
<p class="endtd"></p>
</td></tr>
<tr>
<td><ul>
<li><a href="page_getting_started.html">Getting Started</a><br/>
</li>
<li><a href="page_the_basics.html">The Basics</a><br/>
</li>
<li><a href="page_examples_and_plugins.html">Examples and Plugins</a><br/>
   </li>
</ul>
</td></tr>
<tr>
<td style="background-color: #5a5c5e; text-align: center"><h2 style="color:#FFFFFF">Overviews</h2>
<p class="endtd"></p>
</td></tr>
<tr>
<td><ul>
<li><a href="page_action_management.html">Action Management</a><br/>
</li>
<li><a href="page_tree_structures.html">Building Trees</a><br/>
</li>
<li><a href="page_debugging.html">Debugging Applications</a><br/>
</li>
<li><a href="page_extension_system.html">Extension System</a><br/>
</li>
<li><a href="page_factories.html">Factories</a><br/>
</li>
<li><a href="page_logging.html">Logging</a><br/>
</li>
<li><a href="page_modules_overview.html">Modules</a><br/>
</li>
<li><a href="page_object_management.html">Object Management</a><br/>
</li>
<li><a href="page_observers.html">Observers</a><br/>
</li>
<li><a href="page_observer_widgets.html">Observer Widgets</a><br/>
</li>
<li><a href="page_project_management.html">Project Management</a><br/>
</li>
<li><a href="page_tasking.html">Tasking</a><br/>
</li>
<li><a href="page_widget_set.html">Widget Set</a><br/>
   </li>
</ul>
</td></tr>
</table>
<p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="observers_introduction"></a>
Introduction through simple examples</h1>
<p>This section will introduce basic observer operations through blocks of example code. It is important to understand these example blocks of code before moving on to the sections that follows.</p>
<h2><a class="anchor" id="creating_contexts"></a>
First steps: Creating an observer contexts and attaching objects to it</h2>
<p>This example shows how to create your first observer class and attach objects to it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;QtilitiesCore&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>QtilitiesCore;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the observer</span></div>
<div class="line">Observer* observerA = <span class="keyword">new</span> Observer;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the objects</span></div>
<div class="line">QPointer&lt;QObject&gt; object1 = <span class="keyword">new</span> QObject;</div>
<div class="line">QPointer&lt;QObject&gt; object2 = <span class="keyword">new</span> QObject;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerA-&gt;attachSubject(object1);</div>
<div class="line">observerA &lt;&lt; object2;</div>
</div><!-- fragment --><h2><a class="anchor" id="sharing_objects"></a>
Object sharing: Attaching an object to multiple contexts</h2>
<p>A very powerful feature of the way observers handle attached subjects is that they can be attached to multiple observers. We can append the following to the above example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create another observer</span></div>
<div class="line">Observer* observerB = <span class="keyword">new</span> Observer;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach objects to observers</span></div>
<div class="line">observerB-&gt;attachSubject(object1);</div>
<div class="line">observerB-&gt;attachSubject(object2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the references to all children attached to an observer</span></div>
<div class="line">QList&lt;QObject*&gt; children_B = observerB-&gt;subjectReferences();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the number of children</span></div>
<div class="line"><span class="keywordtype">int</span> number_children_B = observerB-&gt;subjectCount();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the number of parents</span></div>
<div class="line"><span class="keywordtype">int</span> parent_count_1 = Observer::parentCount(object1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the references of any objects&#39; parents</span></div>
<div class="line">QList&lt;Observer*&gt; parents_object1 = Observer::parentReferences(object1);</div>
</div><!-- fragment --><p>The above code example also shows how to get the references to an object's parents, and how to get the number of subjects inside an observer context along with and their references.</p>
<h2><a class="anchor" id="observer_subject_IDs"></a>
Observer &amp; Subject IDs: Accessing objects using unique IDs</h2>
<p>Every observer created in your application will have an unique integer ID associated with it. This value is assigned to the observer by the object manager in its constructor. The ID of an observer can be accessed using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aceb6d2edf30c840d0b9dc543b2180737" title="Returns the uqniue ID assigned to this observer by the ObjectManager.">Qtilities::Core::Observer::observerID()</a> function. It is also possible to access any observer instance through the <a class="el" href="class_qtilities_1_1_core_1_1_object_manager.html#aed398b6525e58788e55eded8e69d31f2" title="Gets the reference to an observer.">Qtilities::Core::ObjectManager::observerReference()</a> function.</p>
<p>When an object is attached to one or more observers it is assigned an unique ID within each context. The ID is stored on the object using the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html#a8095a6f2402f5407afa53dfa8580c7ce" title="Observer Subject IDs Property">Qtilities::Core::Properties::qti_prop_OBSERVER_MAP</a> dynamic property. The <a class="el" href="page_observers.html#qtilities_properties">Dynamic properties used and managed by Observers</a> section explores dynamic properties in detail.</p>
<h2><a class="anchor" id="object_categories"></a>
Object categories: Organizing objects into categories inside a context</h2>
<p>When objects should be managed into categories inside an observer it can be done by setting the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html#a4ef6b89e9ce031009f82eba057862839" title="Object Category Property.">Qtilities::Core::Properties::qti_prop_CATEGORY_MAP</a> property on an object before attaching it to an observer which has its Qtilities::Core::Observer::HierarchicalDisplay hint set to categorized hierarchy. When viewing such an observer using the <a class="el" href="class_qtilities_1_1_core_gui_1_1_observer_widget.html" title="The ObserverWidget class provides a ready-to-use widget to display information about a specific obser...">Qtilities::CoreGui::ObserverWidget</a> class it will show the objects under such observers using the categories specified on the objects.</p>
<p>For examples of how observer widgets visualize categories, see the <a class="el" href="page_observer_widgets.html#hierarchical_display">Hierarchical (categorized) display options</a> section of the <a class="el" href="page_observer_widgets.html">Observer Widgets</a> article.</p>
<h2><a class="anchor" id="object_lifetimes"></a>
Object lifetimes: Managing object lifetimes using observers</h2>
<p>When attaching objects to observers, it is possible to specify the way the object should be managed by the observer context. The possible management options are defined in the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aee321cdb07667b5fe20d03a59e9ff17e" title="The possible ownerships with which subjects can be attached to an observer.">Qtilities::Core::Observer::ObjectOwnership</a> enumeration. The ownership of any object observed by one or more observers is stored using the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html#ae8dc4ca6020c522e245eec11ba6cbc54" title="Object Ownership Property.">Qtilities::Core::Properties::qti_prop_OWNERSHIP</a> property.</p>
<h1><a class="anchor" id="qtilities_properties"></a>
Dynamic properties used and managed by Observers</h1>
<p>Observer classes use the dynamic property features of QObject classes extensively to manage objects in contexts. This section will explain how to use these properties, which properties exists and how property changes can be monitored. The sections to follow will explain the different properties which is used in Qtilities, however new custom properties can easily be created and added to objects since the observer property classes are basically wrappers around QVariant.</p>
<p>The object manager provides the <a class="el" href="class_qtilities_1_1_core_1_1_object_manager.html#a0d12d722ac65c4c4bfae21ea8e4118ae" title="Convenience function to check if a dynamic property exists on a object.">Qtilities::Core::ObjectManager::propertyExists()</a> function which can be used to check if a property exists on an object.</p>
<h2><a class="anchor" id="different_properties"></a>
Different property types</h2>
<p>At present, two types of properties are used:</p>
<ul>
<li><a class="el" href="class_qtilities_1_1_core_1_1_multi_context_property.html" title="A MultiContextProperty provides a property which has different values in different contexts...">Qtilities::Core::MultiContextProperty</a> : Used to store properties which are different between different contexts.</li>
<li><a class="el" href="class_qtilities_1_1_core_1_1_shared_property.html" title="A SharedProperty is a basic implementation of QtilitiesProperty.">Qtilities::Core::SharedProperty</a> : Used to store properties which remain the same between different contexts.</li>
</ul>
<p>Getting and setting of properties are done by the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Qtilities::Core::Observer</a> class which provides easy to use functions to set and get properties and their values. For shared properties it is easy to get and set the value of the property because we do not need to know the context since the value is the same for all contexts. For normal observer properties we need to know the context since the value is different for different contexts. See the respective property class documentation for more information about setting and getting different properties.</p>
<h2><a class="anchor" id="important_properties"></a>
Important properties and how they are interpreted</h2>
<p>As mentioned earlier in this section, Qtilities uses a number of properties internally to manage objects in different contexts. All these properties are defined and documented in the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html" title="Namespace containing reserved observer properties used inside the Core Module.">Qtilities::Core::Properties</a> namespace.</p>
<p>Some of these properties are reserved and cannot be changed (see the Permission section of each property's description) by the developer. These properties should not be modified, and if an attempt is made to modify them the property change event will be filtered by the observer and the property will stay unchanged. A list of reserved properties can be obtained through the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9f5624a60522c9885aca302b5aa1a166" title="This function returns a QStringList with the names of all the reserved properties inside this observe...">Qtilities::Core::Observer::reservedProperties()</a> method and the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#abecf544807a89ac1e4150bb08098b254" title="A signal which is emitted as soon as an property change event is filtered.">Qtilities::Core::Observer::propertyChangeFiltered()</a> signal will be emitted when a property change was filtered.</p>
<p>Other properties can be set by the developer before attachment to observers to provide information to the observer about how the object must be treated. The documentation of the different properties provides more details.</p>
<h2><a class="anchor" id="monitoring_property_changes"></a>
Monitoring property changes and changing properties</h2>
<p>A powerful feature of the observer and observer property combination is that changes to properties are detected by observers and handled accordingly. A list of the monitored properties for a specific context can be obtained using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aab01469a6574cad08f38247f25c174fd" title="This function returns a QStringList with the names of all the properties which are monitored by this ...">Qtilities::Core::Observer::monitoredProperties()</a> function. This function also takes into account the monitored properties of all subject filters installed in the context.</p>
<p>To change a property is easy, but care should be taken when changing properties which are different between contexts: </p>
<div class="fragment"><div class="line"><span class="comment">// First check if the property exists. If it does we need to change only the context we</span></div>
<div class="line"><span class="comment">// are interested in. If we replace the complete property we will lose the information</span></div>
<div class="line"><span class="comment">// for all other contexts.</span></div>
<div class="line"><span class="keywordflow">if</span> (ObjectManager::propertyExists(obj,qti_prop_CATEGORY_MAP)) {</div>
<div class="line">    MultiContextProperty category_property = ObjectManager::getMultiContextProperty(obj,qti_prop_CATEGORY_MAP);</div>
<div class="line">    category_property.setValue(qVariantFromValue(NEW_CATEGORY),OBSERVER_ID);</div>
<div class="line">    ObjectManager::setMultiContextProperty(obj,category_property);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    MultiContextProperty category_property(qti_prop_CATEGORY_MAP);</div>
<div class="line">    category_property.setValue(qVariantFromValue(NEW_CATEGORY),OBSERVER_ID);</div>
<div class="line">    ObjectManager::setMultiContextProperty(obj,category_property);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If an observer has an activity policy filter installed and the <a class="el" href="namespace_qtilities_1_1_core_1_1_properties.html#a2b96a7ea53c93ce913e2e27e8510e3bb" title="Object Activity Property.">Qtilities::Core::Properties::qti_prop_ACTIVITY_MAP</a> property on an object within the context is changed, the change will be detected by the observer and passed to the activity policy filter. The filter will then validate the activity state of all objects in the context. The way the validation is performed depends on the setup of the activity policy filter. The property change is thus validated by all the attached subject filters and by the observer itself.</p>
<p>For properties which has the "Change Notifications" parameter as Yes in their documentation, notifications are available when property changes were valid in the following ways (always both):</p>
<ul>
<li>The <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#aaeef96b6b380c12667adb82c48f7cdc2" title="A signal which is emitted as soon as a monitored property of the observer or any of the installed sub...">Qtilities::Core::Observer::monitoredPropertyChanged()</a> signal is emitted with information about the change.</li>
<li>When <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a87d841260596abf11e47d4e66a35ecc0" title="This function enables/disables delivery of QtilitiesPropertyChangeEvents on objects when property cha...">Qtilities::Core::Observer::toggleQtilitiesPropertyChangeEvents()</a> is enabled a <a class="el" href="class_qtilities_1_1_core_1_1_qtilities_property_change_event.html" title="The QtilitiesPropertyChangeEvent is an event which is posted to objects to notify them about property...">Qtilities::Core::QtilitiesPropertyChangeEvent</a> event is delivered to the object on which the change took place. It is important to note that events can only be delivered to objects which are in the same thread as the observer. This is a Qt limitation and if this is a problem in your implementation you should rather use the first notification method. If an object is attached to two observers, the notifications will not happen more than once if necessary.</li>
</ul>
<p>It is easy to catch property change events on an object to which it is delivered. For example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyObject::eventFilter(QObject *<span class="keywordtype">object</span>, QEvent *event) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">object</span> == <span class="keyword">this</span> &amp;&amp; event-&gt;type() == QEvent::User) {</div>
<div class="line">        QtilitiesPropertyChangeEvent* qtilities_event = <span class="keyword">static_cast&lt;</span>QtilitiesPropertyChangeEvent *<span class="keyword">&gt;</span> (event);</div>
<div class="line">        <span class="keywordflow">if</span> (qtilities_event) {</div>
<div class="line">            <span class="comment">// Lets check for example if the qti_prop_NAME property changed:</span></div>
<div class="line">            <span class="keywordflow">if</span> (!qstrcmp(qtilities_event-&gt;propertyName().data(),<a class="code" href="namespace_qtilities_1_1_core_1_1_properties.html#a874184ec7de3e9056cfe510f4caee8ae" title="Object Name Property.">qti_prop_NAME</a>)) {</div>
<div class="line">                <span class="comment">// Remembering that qti_prop_NAME is managed by a name manager and that </span></div>
<div class="line">                <span class="comment">// it is sync&#39;ed with objectName(), we can now get the new name of the object.</span></div>
<div class="line">                QString new_name = objectName();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="subject_filters"></a>
Subject filters</h1>
<p>Subject filters are a feature of the observer architecture which allows control over object attachment and detachment, as well as monitoring of properties introduced by the subject filter.</p>
<p>All subject filters must inherit <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html" title="The AbstractSubjectFilter class provides the abstract interface for observer subject filters...">Qtilities::Core::AbstractSubjectFilter</a>. You can install subject filters using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ad6c48e66ac4dadb59760923d7915abc6" title="Installs a new subject filter.">Qtilities::Core::Observer::installSubjectFilter()</a> function and uninstall subject filters using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a7951f5470f8fd0f48dca72bf3e162bd4" title="Uninstalls a subject filter.">Qtilities::Core::Observer::uninstallSubjectFilter()</a> function. A subject filter can only be used in one observer at any time.</p>
<h2><a class="anchor" id="subject_filter_attachment_involvement"></a>
Attaching an object to an observer context with subject filters</h2>
<p>When attaching an object to an observer context which has subject filters installed, these filters are called during the attachment process to validate the attachment and to make sure all other objects in the context are in the correct state as well after the object was attached. Subject filters normally also add properties to the attached object. The diagram below shows when the <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html#a801f83b6960d91f37a4d20f93eca5005" title="Initialize the attachment of a new subject to the filter&#39;s observer context.">Qtilities::Core::AbstractSubjectFilter::initializeAttachment()</a> and <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html#af9e3be6e047fabdae7029561346844ed" title="Finalize the attachment of a the subject to the filter&#39;s observer context.">Qtilities::Core::AbstractSubjectFilter::finalizeAttachment()</a> functions are called during attachment of an object.</p>
<div class="image">
<img src="subject_filters_attachment.jpg" alt="subject_filters_attachment.jpg"/>
<div class="caption">
Subject Filter Attachment Sequence</div></div>
<p> Detachment of an object can happen in two ways:</p>
<ul>
<li>By calling the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a9eacee75add5520dd269b1ee880e70f2" title="Will attempt to detach the specified object from the observer.">Qtilities::Core::Observer::detachSubject()</a> function</li>
<li>By deleting an object observed by an observer.</li>
</ul>
<p>The detachment process is slightly different for the two cases. The first diagram below shows the case where the detach function is called directly.</p>
<div class="image">
<img src="subject_filters_detachment.jpg" alt="subject_filters_detachment.jpg"/>
<div class="caption">
Subject Filter Detachment Sequence</div></div>
<p> The diagram below shows the case where the object is deleted while attached to the observer. In this case the private slot <code>handle_deletedSubject()</code> on the observer instance is called.</p>
<div class="image">
<img src="subject_filters_object_deletion.jpg" alt="subject_filters_object_deletion.jpg"/>
<div class="caption">
Subject Filter Detachment Sequence (Object Deletion)</div></div>
<p> Another important feature of the observer implementation is that subject filters can indicate to the observer in which they are installed which properties must be monitored. This allows subject filters to validate property changes to the properties added to subjects by the filter.</p>
<h2><a class="anchor" id="context_activity"></a>
Managing context activity</h2>
<p>A common requirement in a context is to manage the activity of objects within the context. The <a class="el" href="class_qtilities_1_1_core_1_1_activity_policy_filter.html" title="The ActivityPolicyFilter class is an implementation of AbstractSubjectFilter which allows control ove...">Qtilities::Core::ActivityPolicyFilter</a> class was designed for this purpose and has many different options allowing precise control over object activity within a context. See the class documentation for more information about this filter.</p>
<h2><a class="anchor" id="managing_names"></a>
Managing names within a context</h2>
<p>Another common requirement in a context is to manage the names of objects within the context. The <a class="el" href="class_qtilities_1_1_core_gui_1_1_naming_policy_filter.html" title="The NamingPolicyFilter class is an implementation of AbstractSubjectFilter which allows control over ...">Qtilities::CoreGui::NamingPolicyFilter</a> class was designed for this purpose and has many different options allowing precise control over object names within a context. See the class documentation for more information about this filter.</p>
<h2><a class="anchor" id="managing_object_types"></a>
Managing object types within a context</h2>
<p>From a developers perspective it might be useful to control the type of objects which can be attached to a context. The <a class="el" href="class_qtilities_1_1_core_1_1_subject_type_filter.html" title="A subject filter which only allows attachement of specific object types.">Qtilities::Core::SubjectTypeFilter</a> class was designed for this purpose and has different filtering options allowing precise control over what types of objects can be attached to a context. See the class documentation for more information about this filter.</p>
<h2><a class="anchor" id="custom_filters"></a>
Creating custom subject filters</h2>
<p>Creating custom subject filters is an easy task if you understand how the initialization and finalization diagrams shown above work. The <a class="el" href="class_qtilities_1_1_core_1_1_subject_filter_template.html" title="A template subject filter.">Qtilities::Core::SubjectFilterTemplate</a> class is included in the Core module and should be used as a starting point when creating new subject filters. The new filter class needs to inherit from <a class="el" href="class_qtilities_1_1_core_1_1_abstract_subject_filter.html" title="The AbstractSubjectFilter class provides the abstract interface for observer subject filters...">Qtilities::Core::AbstractSubjectFilter</a> and re-implement the virtual abstract functions in order to work. The source code of the subject filters which comes as part of Qtilities is a good place to start when looking for examples of filter implementations.</p>
<h1><a class="anchor" id="observer_advanced_topics"></a>
Advanced topics</h1>
<h2><a class="anchor" id="context_dependency"></a>
Context dependency: Creating context aware classes</h2>
<p>In some cases it is desirable to have a class which depends on an observer context. For such cases the <a class="el" href="class_qtilities_1_1_core_1_1_observer_aware_base.html" title="The ObserverAwareBase class provides everything that is needed to make an object aware of an observer...">Qtilities::Core::ObserverAwareBase</a> class was created. Classes can inherit from this class which will add two functions to your class:</p>
<ul>
<li><code>setObserverContext()</code> : A function to set the observer context for the class.</li>
<li><code>observerContext()</code> : A function to get the observer context for the class.</li>
</ul>
<p>It is then possible to access the observer context using the protected variable <code>d_observer</code>. This reference is a QPointer, thus it will detect when the observer context is deleted and will be set to 0.</p>
<h2><a class="anchor" id="observer_hints"></a>
Observer hints: Define the way your context must be displayed</h2>
<p>The observer class provides a concept called observer hints. These hints are called display hints since they guide widgets displaying the context of the observer. The available hints are defined in the <a class="el" href="class_qtilities_1_1_core_1_1_observer_hints.html" title="The ObserverHints class contains display hints for an Observer class.">Qtilities::Core::ObserverHints</a> class and can be used on any observer by calling the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae61374a82580a82b344f599dec661fe0" title="Function which constructs hints for this observer.">Qtilities::Core::Observer::useDisplayHints()</a> function after the observer was constructed. The <a class="el" href="page_observer_widgets.html">Observer Widgets</a> article explores these different hints and shows what their effects are on the visualized observer context.</p>
<h2><a class="anchor" id="batch_processing"></a>
Batch processing: Optimization using processing cycles</h2>
<p>When doing intensive processing on an observer, for example attaching 1000 objects to it, things can get pretty slow since each attachment will emit signals which will cause views connected to the observer to be updated. For this reason the observer class provides the concept of processing cycles.</p>
<p>It is possible to start a processing cycle using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a831844b0810e443776f8a2cf0b5e4d01" title="Starts a processing cycle.">Qtilities::Core::Observer::startProcessingCycle()</a> function. After this function call you can do intensive processing on the observer and when you are done the processing cycle can be finished using the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a1c355778ad9caa8a9237f192a7a6a12e" title="Ends a processing cycle.">Qtilities::Core::Observer::endProcessingCycle()</a>. After the processing cycle was ended the necessary updates can be done manually. For example if you changed the layout of the observer, you can call the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a240709fed2b99aba07424d19ec80de0c" title="Function to refresh the layout views showing this observer.">Qtilities::Core::Observer::refreshViewsLayout()</a> function. If you only changed data in the context, you can call the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ae0cfe4e31430b26561a3343eac0174c4" title="Function to refresh the data views showing this observer.">Qtilities::Core::Observer::refreshViewsData()</a> function.</p>
<h2><a class="anchor" id="modification_state"></a>
Modification state: Check if an observer changed</h2>
<p>The observer class implements the <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_modification_notifier.html" title="Interface which allows objects to broadcast changes made to them.">Qtilities::Core::Interfaces::IModificationNotifier</a> interface. Thus it is possible to monitor the notification state of an observer and its subjects. When attaching an object to an observer the attachment function will check if the object implements this interface as well, and if it does the observer will take the object's state into account when reporting on its own modification state. Observers also take any changes to themselves into account, this includes hierarchical structure changes, hints etc.</p>
<p>Observers also provide a number of signals which can be monitored if you are interested in specific changes in an observer context. See the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html" title="The observer class is an extended implementation of an observer in the subject-observer pattern...">Qtilities::Core::Observer</a> class documentation for more information.</p>
<h2><a class="anchor" id="exporting_importing"></a>
Exporting and importing observers</h2>
<p>The observer class implements the <a class="el" href="class_qtilities_1_1_core_1_1_interfaces_1_1_i_exportable.html" title="Objects can implement this interface if they are able to export and reconstruct themselves.">Qtilities::Core::Interfaces::IExportable</a> interface making it exportable. When a tree is exported, a recursive search for any objects in the tree implementing this interface occurs and the objects found is part of the exported object.</p>
<p>For more information on this topic, see <a class="el" href="page_tree_structures.html#tree_xml">Saving and loading trees using XML</a> for examples of XML exports on observer structures.</p>
<h2><a class="anchor" id="building_trees"></a>
Using observers to build hierarchical trees</h2>
<p>Observers has the only requirement that objects attached to them must be QObjects, therefore it is also possible to attach observers to other observers because an observer is a QObject. This makes construction of tree structures using observer very easy. For more information, see the <a class="el" href="page_tree_structures.html">Building Trees</a> article.</p>
<h2><a class="anchor" id="access_modes"></a>
Access modes: Define user access on a per context basis</h2>
<p>Observers provide access control functionality through the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0f358e1fd5410c64067c687691947ea3" title="Function to set the observer&#39;s access mode. Set the access mode after construction. When subclassing Observer, set it in your constructor.">Qtilities::Core::Observer::setAccessMode()</a> and <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a546182e85f9c9800adb6eae244aa9412" title="Function to set the observer&#39;s access mode scope.">Qtilities::Core::Observer::setAccessModeScope()</a> functions. The possible access modes are provided through the <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a62e08632625c83703a4e5864ff83f374" title="The possible access modes of the observer.">Qtilities::Core::Observer::AccessMode</a> enumeration. Item views and observer functions take the access mode into account when displaying observer contexts or when attempting to modify observers. A convenient function that can be used to check if the access mode of an observer allows the observer to be changed is <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#ac46da1fd6151e3ee699729387ef6e52a" title="This function will validate changes to the observer, or to a specific observer category if specified...">Qtilities::Core::Observer::isConst()</a>. Access modes can also be set on a category level, for more information see <a class="el" href="class_qtilities_1_1_core_1_1_observer.html#a0b9134f8702c6b25ea62d6bc75efac89" title="Function to return the access mode scope of the observer.">Qtilities::Core::Observer::accessModeScope()</a>.</p>
<p>The <a class="el" href="page_observer_widgets.html#access_mode">Access mode and access mode scope</a> section of the <a class="el" href="page_observer_widgets.html">Observer Widgets</a> article shows how the observer widget class customizes its display of observer contexts for different access modes. </p>
</div></div><!-- contents -->
<br><table style="table-layout:auto;	margin: auto; 	border-width:0px 0px 0px 0px; 	border-color:#7F7F7F; 	width:99%;	border-style:solid" CELLPADDING=5 RULES=ROWS FRAME=HSIDES><tr><td style="align: left;width:45%"><a href="http://www.qtilities.org" title="Qtilities Website">Qtilities</a> : <a href="index.html" title="Go back to index">Reference Documentation</a></td><td style="align: center;width:10%"><a href="#top" title="Back to top">Back to top</a> </td><td style="text-align: right;width:45%">Copyright &copy; 2009-2013, Floware Computing (Pty) Ltd</tr></table><br><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-17785825-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script>
