/****************************************************************************
**
** Copyright (c) 2009-2010, Jaco Naude
**
** This file is part of Qtilities which is released under the following
** licensing options.
**
** Option 1: Open Source
** Under this license Qtilities is free software: you can
** redistribute it and/or modify it under the terms of the GNU General
** Public License as published by the Free Software Foundation, either
** version 3 of the License, or (at your option) any later version.
**
** Qtilities is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with Qtilities. If not, see http://www.gnu.org/licenses/.
**
** Option 2: Commercial
** Alternatively, this library is also released under a commercial license
** that allows the development of closed source proprietary applications
** without restrictions on licensing. For more information on this option,
** please see the project website's licensing page:
** http://www.qtilities.org/licensing.html
**
** If you are unsure which license is appropriate for your use, please
** contact support@qtilities.org.
**
****************************************************************************/

#ifndef NAMINGPOLICYINPUTDIALOG_H
#define NAMINGPOLICYINPUTDIALOG_H

#include <QDialog>
#include <QIcon>
#include <QString>
#include "NamingPolicyFilter.h"

namespace Ui {
    class NamingPolicyInputDialog;
}

namespace Qtilities {
    namespace CoreGui {
        /*!
          \class NamingPolicyInputDialog
          \brief The NamingPolicyInputDialog class provides a dialog which allows the user to select how to resolve a naming conflict.

          The NamingPolicyInputDialog is used when a naming policy filter detects a conflict and its resolution policy
          is set to PromptUser. The dialog presents the user with possible options on how to resolve the conflict.

          Below is an example of the dialog in action.

          \image html naming_policy_input_dialog.jpg "Naming Policy Input Dialog"
          \image latex naming_policy_input_dialog.eps "Naming Policy Input Dialog" width=5in
          \sa NamingPolicyFilter
         */
        class NamingPolicyInputDialog : public QDialog {
            Q_OBJECT

            friend class NamingPolicyFilter;

        public:
            NamingPolicyInputDialog(QWidget *parent = 0);
            ~NamingPolicyInputDialog();

            void setNamingPolicyFilter(NamingPolicyFilter* naming_policy_subject_filter) { subject_filter = naming_policy_subject_filter; }
            void setObject(QObject* obj) { object = obj; }
            void setContext(int context_id, const QString& context_name, const QIcon& window_icon = QIcon());
            bool initialize(NamingPolicyFilter::NameValidity validity_result);

            NamingPolicyFilter::ResolutionPolicy selectedResolution();

            //! Returns the current auto generated name.
            QString autoGeneratedName() const;

            void accept();
            void reject();

            //! Unchecks the "All in this cycle" check box.
            void endValidationCycle();
            //! Indicates if the "All in this cycle" check box is selected.
            bool useCycleResolution() const;

        public slots:
            void handleGeneratedNewNameButton();
            void handleDifferentNameChange(QString new_text);
            void updateStatusMessage();

        protected:
            void changeEvent(QEvent *e);

        private:
            //! Function which sets the name of the object set using setObject().
            /*!
              This function checks if the subject filter is the name manager of the object, in that case
              it sets OBJECT_NAME. If not, it sets INSTANCE_NAMES with the subject filter's observer context ID.
              */
            void setName(const QString& new_name);
            //! Function which gets the name of the object set using setObject().
            /*!
              This function checks if the subject filter is the name manager of the object, in that case
              it uses OBJECT_NAME. If not, it uses INSTANCE_NAMES with the subject filter's observer context ID.
              */
            QString getName();

            NamingPolicyFilter* subject_filter;
            QString observer_context;
            int observer_id;
            QObject* object;
            QObject* conflicting_object;
            Ui::NamingPolicyInputDialog *ui;
        };
    }
}

#endif // NAMINGPOLICYINPUTDIALOG_H
